<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://alhassy.github.io/rss.xml"
      title="RSS feed for https://alhassy.github.io/"/>
<title>Life & Computing Science</title>

<link rel="stylesheet" type="text/css" href="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/css/tooltipster.bundle.min.css"/>

<link rel="stylesheet" type="text/css" href="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/css/plugins/tooltipster/sideTip/themes/tooltipster-sideTip-punk.min.css" />

<script type="text/javascript" src="https://code.jquery.com/jquery-1.10.0.min.js"></script>

 <script type="text/javascript"            src="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/js/tooltipster.bundle.min.js"></script>

  <script>
         $(document).ready(function() {
             $('.tooltip').tooltipster({
                 theme: 'tooltipster-punk',
                 contentAsHTML: true,
                 animation: 'grow',
                 delay: [100,500],
                 // trigger: 'click'
                 trigger: 'custom',
                 triggerOpen: {
                     mouseenter: true
                 },
                 triggerClose: {
                     originClick: true,
                     scroll: true
                 }
 });
         });
     </script>

<style>
   abbr {color: red;}

   .tooltip { border-bottom: 1px dotted #000;
              color:red;
              text-decoration: none;}
</style>
<meta name="author" content="Musa Al-hassy">
<meta name="referrer" content="no-referrer">
<link href="usual-org-front-matter.css" rel="stylesheet" type="text/css" />
<link href="org-notes-style.css" rel="stylesheet" type="text/css" />
<link href="floating-toc.css" rel="stylesheet" type="text/css" />
<link href="blog-banner.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="images/favicon.png">

<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
,*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>

</head>
<body>
<div id="preamble" class="status"><div class="header">
  <a href="https://alhassy.github.io/" class="logo">Life & Computing Science</a>
  <br>
    <a href="https://alhassy.github.io/AlBasmala">AlBasmala</a>
    <a href="https://alhassy.github.io/archive">Archive</a>
    <a href="https://alhassy.github.io/tags">Tags</a>
    <a href="https://alhassy.github.io/rss.xml">RSS</a>
    <a href="https://alhassy.github.io/about">About</a>
</div></div>
<div id="content">
<h1 class="title">Posts tagged "agda":</h1>
<h1 class="post-title"><div class="title" style="padding-bottom: 0px"><a href="https://alhassy.github.io/PathCat.html">Graphs are to categories as lists are to monoids</a></h1></div><center> <img src="images/PathCat.png" alt="Article image"
  width="300" height="300" align="top" /> </center><br><center><strong>Abstract</strong></center>
<div id="myMathJaxStuff" style="display: none;">
<p>
We do not want the MathJax declarations to use vertical whitespace;
so we do not display their residual whitespace.
</p>

<p>
Moreover the form of MathJax declarations differs from usual LaTeX
declarations, so we iffalse&#x2026;fi these ones.
</p>

<p>
Commenting the MathJax using &lt;!&#x2013; HTML comments &#x2013;&gt;
makes the commands inaccessible elsewhere.
</p>

<p>
The alternative is to declare a <a href="https://stackoverflow.com/questions/1992114/how-do-you-create-a-hidden-div-that-doesnt-create-a-line-break-or-horizontal-sp">non-displayed ~div</a>~.
</p>

<p>
\[\newcommand{\step}[1]{ \\ = \;\; & \qquad \color{maroon}{âŸ¨ \text{ #1 } âŸ©} \\ & }\]
\[\newcommand{\stepWith}[2]{ \\ #1 \;\; & \qquad \color{maroon}{âŸ¨ \text{ #2 } âŸ©} \\ & }\]
\[\newenvironment{calc}{\begin{align*} & }{\end{align*}}\]
</p>

<p>
Having identical label references for different equations will break rendering!
</p>

<p>
eqn            := display name, then display formula.
eqnColour      := display name, then display formula, then colour
eqnLabel       := display name, then display formula, then label
eqnLabelColour := display name, then display formula, then label, then colour
eqnLabelColour := display name, then display formula, then colour, then label &#x2013; safe redundancy!
</p>

<p>
\[\newcommand{\eqnLabelColour}[4]{ \begin{equation} \color{#4}{#2} \label{#3}\tag{$\color{#4}{\text{#1}}$} \end{equation} }\]
</p>

<p>
\[\newcommand{\eqnColourLabel}[4]{ \eqnLabelColour{#1}{#2}{#4}{#3} }\]
</p>

<p>
Default equation colour is: navy
\[\newcommand{\eqnLabel}[3]{ \eqnLabelColour{#1}{#2}{#3}{navy} }\]
</p>

<p>
Default label is the display name
\[\newcommand{\eqnColour}[3]{ \eqnLabelColour{#1}{#2}{#1}{#3} }\]
</p>

<p>
\[\newcommand{\eqn}[2]{ \eqnLabel{#1}{#2}{#1} }\]
</p>

<p>
Notice that \ref{Label} and \ref{Label2} have the same displayed name,
but <b>cannot</b> have the same label!
</p>

<p>
\[\newcommand{\givens}[1]{ \color{teal}{#1} }\]
\[\newcommand{\requireds}[1]{ \color{navy}{#1} }\]
</p>

<p>
\[\def\lands{\;\land\;}\]
\[\def\landS{\quad\land\quad}\]
</p>

<p>
\[\def\impliess{\;\Rightarrow\;}\]
\[\def\impliesS{\quad\Rightarrow\quad}\]
</p>

<p>
\[\def\equivs{\;\equiv\;}\]
\[\def\equivS{\quad\equiv\quad}\]
</p>

<p>
\[\def\eqs{\;=\;}\]
\[\def\eqS{\quad=\quad}\]
</p>

<p>
\[\def\sqleqs{\;\sqsubseteq\;}\]
\[\def\sqleqS{\quad\sqsubseteq\quad}\]
</p>

<p>
\[\def\foldr{\mathsf{foldr}}\]
\[\def\edge{\mathsf{edge}}\]
\[\def\Func{\mathsf{Func}}\]
\[\def\Id{\mathsf{Id}}\]
\[\def\src{\mathsf{src}}\]
\[\def\tgt{\mathsf{tgt}}\]
\[\def\obj{\mathsf{obj}}\]
\[\def\mor{\mathsf{mor}}\]
\[\def\natTo{\overset{.}{â†’}}\]
\[\def\Obj{\mathsf{Obj}\,}\]
\[\def\List{\mathsf{List}\,}\]
</p>
<p>
After this, only pure latex commands should exist.
</p>

<p>
However, the whitespace they produce via MathJax is ignored
since the HTML div is not yet closed.
</p>


</div>

<style> pre.src-haskell:before { content: 'Agda' !important; }</style>

<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#Introduction">Introduction</a>
<ul>
<li><a href="#Imports">Imports</a></li>
</ul>
</li>
<li><a href="#Graph-me-to-the-moon"><i>Graph me to the moon!</i></a>
<ul>
<li><a href="#Types-Require-Casting">Types Require Casting</a></li>
<li><a href="#Signatures">Signatures</a></li>
</ul>
</li>
<li><a href="#Cats-but-no-alligators"><i>Cats but no alligators</i></a>
<ul>
<li><a href="#Strict-Categories">Strict Categories</a></li>
<li><a href="#Familiar-ğ’®â„¯ğ“‰-tings">Familiar <code>ğ’®â„¯ğ“‰</code>-tings</a></li>
</ul>
</li>
<li><a href="#Endowing-Structure-with-Functors"><i>Endowing Structure with Functors</i></a>
<ul>
<li><a href="#Functor-Examples">Examples</a></li>
</ul>
</li>
<li><a href="#The-four-postulates-of-the-apocalypse"><i>The four postulates of the apocalypse</i></a>
<ul>
<li><a href="#A-very-big-ğ’ğ’¶ğ“‰">A very big <code>ğ’ğ’¶ğ“‰</code></a></li>
<li><a href="#ğ’¢ğ“‡ğ’¶ğ“…ğ’½"><code>ğ’¢ğ“‡ğ’¶ğ“…ğ’½</code></a></li>
<li><a href="#ğ’ğ’¶ğ“‰-'s-are-ğ’¢ğ“‡ğ’¶ğ“…ğ’½-'s"><code>ğ’ğ’¶ğ“‰</code>'s are <code>ğ’¢ğ“‡ğ’¶ğ“…ğ’½</code>'s</a></li>
</ul>
</li>
<li><a href="#How-natural-is-naturality"><i>How natural is naturality?</i></a>
<ul>
<li><a href="#Identification-of-possible-paths-contraction-of-choices">Identification of possible paths &#x2014;contraction of choices</a></li>
<li><a href="#No-Choice-free-will-is-only-an-illusion">No Choice &#x2013;free will is only an illusion</a></li>
<li><a href="#Natural-means-polymorphic-without-type-inspection">Natural means polymorphic without type inspection</a></li>
<li><a href="#Natural-means-no-reference-to-types">Natural means no reference to types</a></li>
<li><a href="#Natural-means-uniformly-and-simultaneously-defined">Natural means uniformly and simultaneously defined</a></li>
<li><a href="#Naturality-is-restructure-modify-commutativity">Naturality is restructure-modify commutativity</a></li>
<li><a href="#Natural-means-obvious">Natural means obvious</a></li>
<li><a href="#Naturality-is-promotion">Naturality is promotion</a></li>
<li><a href="#Naturality-as-a-rewrite-rule">Naturality as a rewrite rule</a></li>
<li><a href="#Naturality-is-just-model-morphism">Naturality is just model morphism</a></li>
<li><a href="#Naturality-yields-pattern-matching">Naturality yields pattern matching</a></li>
<li><a href="#Naturality-Examples">Examples</a></li>
</ul>
</li>
<li><a href="#Functor-Categories"><i>Functor Categories</i></a>
<ul>
<li><a href="#FunctorCats-Examples">Examples</a></li>
<li><a href="#Graphs-as-functors">Graphs as functors</a></li>
</ul>
</li>
<li><a href="#A-few-categorical-constructions">A few categorical constructions</a>
<ul>
<li><a href="#Opposite">Opposite</a></li>
<li><a href="#Products">Products</a></li>
<li><a href="#Pointwise-extensions-and-the-hom-functor">Pointwise extensions and the hom functor</a></li>
</ul>
</li>
<li><a href="#ğ’®implicity-ğ’°nderlies-ğ’omplexity">ğ’®implicity ğ’°nderlies ğ’omplexity</a>
<ul>
<li><a href="#Being-forgetful-from-injections-to-faithful-functors">Being forgetful: from injections to faithful functors</a></li>
<li><a href="#Of-basis-vectors">Of basis vectors</a></li>
<li><a href="#Of-adjunctions">Of adjunctions</a></li>
<li><a href="#Adjunctions-and-Representable-Functors">Adjunctions and Representable Functors</a></li>
<li><a href="#Concluding-remarks">Concluding remarks</a></li>
</ul>
</li>
<li><a href="#Designing-Paths">Designing Paths</a>
<ul>
<li><a href="#Aside-An-Adjunction-between-ğ’®â„¯ğ“‰-and-ğ’ğ’¶ğ“‰">Aside: An Adjunction between ğ’®â„¯ğ“‰ and ğ’ğ’¶ğ“‰</a></li>
<li><a href="#Equality-Combinators-for-Paths">Equality Combinators for Paths</a></li>
<li><a href="#Category-of-paths-over-a-graph">Category of paths over a graph</a></li>
<li><a href="#The-ğ’«ath-to-freedom">The ğ’«ath to freedom</a></li>
</ul>
</li>
<li><a href="#Free-at-last">Free at last</a>
<ul>
<li><a href="#Defining-the-needed-operations">Defining the needed operations</a></li>
<li><a href="#Realising-the-proof-obligations">Realising the proof-obligations</a></li>
<li><a href="#Another-freedom-proof">Another freedom proof</a></li>
<li><a href="#ğ’«-ğ’°"><code>ğ’« âŠ£ ğ’°</code></a></li>
</ul>
</li>
<li><a href="#Folds-Over-Paths">Folds Over Paths</a>
<ul>
<li><a href="#Lists-are-special-kinds-of-paths">Lists are special kinds of paths</a></li>
</ul>
</li>
<li><a href="#That-was-fun-Bye">That was fun; Bye!</a></li>
</ul>
</div>
</nav>

<p>
Numbers are the lengths of lists which are the flattenings of trees which are
the spannings of graphs.
Unlike the first three, graphs have <i>two</i> underlying types of interest
&#x2013;the vertices and the edges&#x2013; and it is getting to grips with this complexity
that we attempt to tackle by considering their â€˜algebraicâ€™ counterpart: Categories.
</p>

<p>
In our exploration of what graphs could possibly be and their relationships to lists are,
we shall <i>mechanise,</i> or <i>implement,</i> our claims since there will be many details and it is easy
to make mistakes &#x2013;moreover as a self-learning project, I'd feel more confident to make
<b>bold</b> claims when I have a proof assistant checking my work ;-)
</p>

<p>
Assuming slight familiarity with the Agda programming language, we motivate the need for
basic concepts of category theory with the aim of discussing adjunctions with
a running example of a detailed construction and proof of a free functor.
Moreover, the article contains a host of <code>exercises</code> whose solutions can be found in the
literate source file. Raw Agda code can be found <a href="https://github.com/alhassy/AgdaCheatSheet/blob/master/PathCat.agda">here</a>.
</p>

<p>
Since the read time for this article is more than two hours, excluding the interspersed
exercises, it may help to occasionally consult a some reference sheets:
</p>
<div class="org-center">
<p>
<a href="https://alhassy.github.io/CatsCheatSheet/CheatSheet.pdf"><img src="https://img.shields.io/badge/Category_Theory-CheatSheet-success?logo=gimp"></a>
<a href="https://alhassy.github.io/AgdaCheatSheet/CheatSheet.pdf"><img src="https://img.shields.io/badge/Agda-CheatSheet-success?logo=haskell"></a>
</p>
</div>

<p>
Coming from a background in order theory, I love Galois Connections and so
our categorical hammer will not be terminal objects nor limits, but rather adjunctions.
As such, <i>everything is an adjunction</i> is an apt slogan for us :-)
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">This file has been extracted from https://alhassy.github.io/PathCat/</span>
<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Type checks with Agda version 2.6.0.</span>
</pre>
</div>
<small> <center>
<p>
( Photo by
<a href="https://unsplash.com/@miklevasilyev">Mikhail Vasilyev</a>
on <a href="https://unsplash.com/">Unsplash</a> )
</p>
</center> </small>

<div id="outline-container-org82aa0e6" class="outline-2">
<h2 id="Introduction">Introduction</h2>
<div class="outline-text-2" id="text-Introduction">
<p>
Lists give free monoids \(â„’\, A = (\List\, A, +\!+, [])\)
&#x2014;a monoid \(ğ’® = (S, âŠ•, 0_âŠ•)\) is a triple consisting of a set \(S\) with a binary operation
\(âŠ•\) on it that is associative and has a unit, \(0_âŠ•\).
That it is â€˜freeâ€™ means that to define a structure-preserving map between monoids
\((\List\, A, +\!+, []) \,âŸ¶\, (S, âŠ•, 0_âŠ•)\) it suffices to only provide a map between their
carriers \(\List\, A â†’ S\) &#x2014;freedom means that plain old maps between types freely,
at no cost or effort, give rise to maps that preserve monoid structure.
Moreover, the converse also holds and in-fact we have a bijection:
\[
  (â„’\, A âŸ¶ ğ’®) \qquadâ‰…\qquad (A âŸ¶ ğ’°\, ğ’®)
\]
Where we write \(ğ’°\, (S, âŠ•, 0_âŠ•) = S\) for the operation that gives us the ğ’°nderlying carrier
of a monoid.
</p>

<p>
Loosely put, one says we have an â€˜adjunctionâ€™, written \(â„’ âŠ£ ğ’°\).
</p>

<p>
Observe that natural numbers <code>â„• â‰… List Unit</code> are a monoid whose operation is commutative.
By using different kinds of elements <code>A</code> &#x2013;and, importantly, still not imposing any equations&#x2013;
we lose commutativity with <code>List A</code>.
Then by generalising further to binary trees <code>BinTree A</code>, we lose associtivity and identity
are are only left with a set and an operation on it &#x2014;a structure called a â€˜magmaâ€™.
</p>

<p>
This is the order that one usually learns about these inductively built structures.
One might be curious as to what the next step up is in this hierarchy of generalisations.
It is a non-inductive type called a â€˜graphâ€™ and in this note we investigate them by
comparison to lists.
Just as we shifted structures in the hierarchy, we will
move to a setting called a â€˜categoryâ€™ &#x2014;such are more structured than magmas
but less restrictive than monoids.
</p>

<p>
For those who know category theory, this article essentially formalises the
often seen phrase â€œconsider the category generated by this diagram, or graphâ€.
Indeed every category is essentially a free category over a graph but with
additional equations that â€˜confuseâ€™ two paths thereby declaring, e.g., that
one edge is the composition of two other edges.
</p>
</div>

<div id="outline-container-org77904e6" class="outline-3">
<h3 id="Imports">Imports</h3>
<div class="outline-text-3" id="text-Imports">
<p>
In our exploration of what graphs could possibly be and their relationships to lists are,
we shall <i>mechanise</i> or <i>implement</i> our claims since there will be many details and it is easy
to make mistakes &#x2013;moreover as a self-learning project, I'd feel more confident to make
<b>bold</b> claims when I have a proof assistant checking my work ;-)
</p>

<p>
Before reading any further please ingrain into your mind that the Agda keyword
<code>Set</code> is read â€œtypeâ€! This disparity is a historical accident.
</p>

<p>
Since the Agda prelude is so simple, the core language doesnâ€™t even come with Booleans or numbers by default
&#x2014;they must be imported from the standard library. This is a pleasant feature.
As a result, Agda code tends to begin with a host of imports.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">PathCat</span> <span style="color: #859900; font-weight: bold;">where</span>

<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Level</span> using (<span style="color: #b58900; font-style: italic;">Level</span>) renaming (zero to &#8467;&#8320; ; suc to &#8467;suc ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8852;</span><span style="color: #859900; font-weight: bold;">_</span> to <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8845;</span><span style="color: #859900; font-weight: bold;">_</span>)

<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Numbers</span>
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Fin</span>
  using (<span style="color: #b58900; font-style: italic;">Fin</span> ; to&#8469; ; from&#8469; ; from&#8469;<span style="color: #268bd2;">&#8804;</span> ; reduce<span style="color: #268bd2;">&#8805;</span> ; inject<span style="color: #268bd2;">&#8804;</span>)
  renaming (<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&lt;</span><span style="color: #859900; font-weight: bold;">_</span> to _f<span style="color: #268bd2;">&lt;</span><span style="color: #859900; font-weight: bold;">_</span> ; zero to fzero ; suc to fsuc)
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Nat</span>
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Relation.Binary</span> using (<span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">DecTotalOrder</span>)
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Nat.Properties</span> using(<span style="color: #268bd2;">&#8804;-</span>decTotalOrder ; <span style="color: #268bd2;">&#8804;-</span>refl)
<span style="color: #b58900;">open</span> <span style="color: #b58900; font-style: italic;">DecTotalOrder</span> <span style="color: #268bd2;">Data.Nat.Properties.&#8804;-</span>decTotalOrder

<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Z-notation for sums</span>
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Product</span> using (<span style="color: #b58900; font-style: italic;">&#931;</span> ; proj&#8321; ; proj&#8322; ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#215;</span><span style="color: #859900; font-weight: bold;">_</span> ; <span style="color: #859900; font-weight: bold;">_</span>,<span style="color: #859900; font-weight: bold;">_</span>)
<span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #b58900;">&#8758;&#8226;</span> <span style="color: #b58900; font-style: italic;">:</span> {a b <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Level</span>} (<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> a) (<span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> b) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> (a <span style="color: #268bd2;">&#8845;</span> b)
<span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #b58900;">&#8758;&#8226;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#931;</span>
<span style="color: #859900; font-weight: bold;">infix</span> <span style="color: #b58900;">-</span>666 <span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #268bd2;">&#8758;&#8226;</span>
<span style="color: #b58900;">syntax</span> <span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #268bd2;">&#8758;&#8226;</span> <span style="color: #b58900; font-style: italic;">A</span> (&#955; x <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span>) <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#931;</span> x <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8226;</span> <span style="color: #b58900; font-style: italic;">B</span>

<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Equalities</span>
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Relation.Binary.PropositionalEquality</span> using (<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8791;</span><span style="color: #859900; font-weight: bold;">_</span> ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8801;</span><span style="color: #859900; font-weight: bold;">_</span>)
  renaming (sym to <span style="color: #268bd2;">&#8801;-</span>sym ; refl to <span style="color: #268bd2;">&#8801;-</span>refl ; trans to <span style="color: #859900; font-weight: bold;">_</span>&#10216;<span style="color: #268bd2;">&#8801;&#8801;</span>&#10217;<span style="color: #859900; font-weight: bold;">_</span>
           ; cong to <span style="color: #268bd2;">&#8801;-</span>cong ; cong&#8322; to <span style="color: #268bd2;">&#8801;-</span>cong&#8322;
           ; subst to <span style="color: #268bd2;">&#8801;-</span>subst ; subst&#8322; to <span style="color: #268bd2;">&#8801;-</span>subst&#8322; ; setoid to <span style="color: #268bd2;">&#8801;-</span>setoid)
</pre>
</div>

<p>
Notice that we renamed transitivity to be an infix combinator.
</p>

<p>
Let us make equational-style proofs available for any type.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #859900; font-weight: bold;">_</span> {i} {<span style="color: #b58900; font-style: italic;">S</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> i} <span style="color: #859900; font-weight: bold;">where</span>
    open <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Relation.Binary.EqReasoning</span> (<span style="color: #268bd2;">&#8801;-</span>setoid <span style="color: #b58900; font-style: italic;">S</span>) public
</pre>
</div>

<p>
We intend our proofs to be sequences of formulae interleaved with
justifications for how the formulae are related. At times, the justifications
are by definition and so may be omitted, but we may want to mention them
for presentational &#x2013;pedagogical?&#x2013; purposes. Hence, we introduce the
combinator notation <code>lhs â‰¡âŸ¨" by definition of something "âŸ©â€² rhs</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Agda.Builtin.String</span>

defn<span style="color: #b58900;">-</span>chasing <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i} {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> i} (x <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">String</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">A</span>
defn<span style="color: #b58900;">-</span>chasing x reason supposedly<span style="color: #268bd2;">-</span>x<span style="color: #268bd2;">-</span>again <span style="color: #268bd2;">=</span> supposedly<span style="color: #268bd2;">-</span>x<span style="color: #268bd2;">-</span>again

<span style="color: #b58900;">syntax</span> defn<span style="color: #268bd2;">-</span>chasing x reason xish <span style="color: #268bd2;">=</span> x <span style="color: #268bd2;">&#8801;</span>&#10216; reason &#10217;<span style="color: #268bd2;">&#8242;</span> xish

<span style="color: #859900; font-weight: bold;">infixl</span> 3 defn<span style="color: #268bd2;">-</span>chasing
</pre>
</div>

<p>
While weâ€™re making synonyms for readability, letâ€™s make another:
</p>
<div class="org-src-container">
<pre class="src src-haskell">_even<span style="color: #b58900;">-</span>under_ <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {a b} {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> a} {<span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> b} {x y} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8801;</span> y <span style="color: #268bd2;">&#8594;</span> (f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span>) <span style="color: #268bd2;">&#8594;</span> f x <span style="color: #268bd2;">&#8801;</span> f y
_even<span style="color: #b58900;">-</span>under_ <span style="color: #268bd2;">=</span> &#955; eq f <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8801;-</span>cong f eq
</pre>
</div>

<p>
Example usage would be to prove
<code>mor G (mor F Id) â‰¡ mor G Id</code> directly by <code>â‰¡-cong (mor G) (id F)</code>
which can be written more clearly as
<code>functor F preserves-identities even-under (mor G)</code>,
while longer it is also much clearer and easier to read and understand
&#x2013;self-documenting in some sense.
</p>

<p>
Interestingly, our first calculational proof is in section 5 when
we introduced an large ğ’ğ’¶ğ“‰egory.
</p>
</div>
</div>
</div>

<div id="outline-container-org52f311e" class="outline-2">
<h2 id="Graph-me-to-the-moon"><i>Graph me to the moon!</i></h2>
<div class="outline-text-2" id="text-Graph-me-to-the-moon">
<div class="org-center">
<p>
<i>What's a graph? Let's motivate categories!</i>
</p>
</div>
<p>
A â€˜graphâ€™ is just a parallel-pair of maps,
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">Graph</span>&#8320; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>&#8321; <span style="color: #859900; font-weight: bold;">where</span>
  field
    <span style="color: #b58900; font-style: italic;">V</span>   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>
    <span style="color: #b58900; font-style: italic;">E</span>   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>
    src <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span>
    tgt <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span>
</pre>
</div>
<p>
This of-course captures the usual notion of a set of nodes <code>V</code> and a set of directed and labelled
edges <code>E</code> where an edge <code>e</code> begins at <code>src e</code> and concludes at <code>tgt e</code>.
</p>

<p>
What is good about this definition is that it can be phrased in any category: <code>V</code> and <code>E</code> are
any two objects and <code>src, tgt</code> are a parallel pair of morphisms between them.
How wonderful! We can study the notion of graphs in arbitrary categories!
&#x2014;This idea will be made clearer when categories and functors are formally introduced.
</p>

<p>
However, the notion of structure-preserving map between graphs, or â€˜graph-mapsâ€™ for short,
then becomes:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">record</span> _&#119970;<span style="color: #268bd2;">&#10230;</span>&#8320;<span style="color: #859900; font-weight: bold;">_</span> (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>&#8320;) <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>&#8321; <span style="color: #859900; font-weight: bold;">where</span>
  open <span style="color: #b58900; font-style: italic;">Graph</span>&#8320;
  field
    vertex <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>(<span style="color: #b58900; font-style: italic;">G</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span>(<span style="color: #b58900; font-style: italic;">H</span>)
    edge   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">E</span>(<span style="color: #b58900; font-style: italic;">G</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">E</span>(<span style="color: #b58900; font-style: italic;">H</span>)
    src<span style="color: #268bd2;">-</span>preservation <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> e <span style="color: #268bd2;">&#8594;</span> src(<span style="color: #b58900; font-style: italic;">H</span>) (edge e) <span style="color: #268bd2;">&#8801;</span>  vertex (src(<span style="color: #b58900; font-style: italic;">G</span>) e)
    tgt<span style="color: #268bd2;">-</span>preservation <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> e <span style="color: #268bd2;">&#8594;</span> tgt(<span style="color: #b58900; font-style: italic;">H</span>) (edge e) <span style="color: #268bd2;">&#8801;</span>  vertex (tgt(<span style="color: #b58900; font-style: italic;">G</span>) e)
</pre>
</div>
<p>
( The fancy ğ’¢ and âŸ¶ are obtained in Agda input mode by <code>\McG</code> and <code>\--&gt;</code>, respectively. )
</p>

<p>
This is a bit problematic in that we have two proof obligations and at a first glance it is not
at all clear their motivation besides â€˜â€˜structure-preservingâ€™â€™.
</p>

<p>
However, our aim is in graphs in usual type theory, and as such we can use a definition that is
equivalent in this domain: A graph is a
type <code>V</code> of vertices and a â€˜typeâ€™ <code>v âŸ¶ vâ€™</code> of edges for each pair of vertices <code>v</code> and <code>vâ€™</code>.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8216;small graphs&#8217; , since we are not using levels</span>
<span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">Graph</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>&#8321; <span style="color: #859900; font-weight: bold;">where</span>
  field
    <span style="color: #b58900; font-style: italic;">V</span>    <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span>

<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">i.e., Graph &#8776; &#931; V &#8758; Set &#8226; (V &#8594; V)</span>
<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Graphs are a dependent type!</span>
</pre>
</div>

<p>
Now the notion of graph-map, and the meaning of structure-preserving, come to the forefront:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">GraphMap</span> (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>) <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>&#8321; <span style="color: #859900; font-weight: bold;">where</span>
    private
      open <span style="color: #b58900; font-style: italic;">Graph</span> using (<span style="color: #b58900; font-style: italic;">V</span>)
      <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span>g_ <span style="color: #268bd2;">=</span> Graph._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">G</span>
      <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span>h_ <span style="color: #268bd2;">=</span> Graph._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">H</span>
    field
      ver  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>(<span style="color: #b58900; font-style: italic;">G</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span>(<span style="color: #b58900; font-style: italic;">H</span>)                                <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">vertex morphism</span>
      edge <span style="color: #b58900; font-style: italic;">:</span> {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>(<span style="color: #b58900; font-style: italic;">G</span>)} <span style="color: #268bd2;">&#8594;</span> (x <span style="color: #268bd2;">&#10230;</span>g y) <span style="color: #268bd2;">&#8594;</span> (ver x <span style="color: #268bd2;">&#10230;</span>h ver y) <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">arrow preservation</span>

<span style="color: #b58900;">open</span> <span style="color: #b58900; font-style: italic;">GraphMap</span>
</pre>
</div>

<p>
Note <code>edge</code> essentially says that <code>mor</code> â€˜shiftsâ€™, or â€˜translatesâ€™, types
<code>x âŸ¶g y</code> into types <code>ver x âŸ¶h ver y</code>.
</p>

<p>
While equivalent, this two-piece definition is preferable over the four-piece one given
earlier since it means less proof-obligations and less constructions in general, but the same
expressiblity. Yay!
</p>

<p>
Before we move on, let us give an example of a simple chain-graph.
For clarity, we present it in both variations.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">embedding: j &lt; n &#8658; j &lt; suc n</span>
`<span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{n} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Fin</span> n <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Fin</span> (suc n)
` j <span style="color: #268bd2;">=</span> inject<span style="color: #268bd2;">&#8804;</span> j (<span style="color: #268bd2;">&#8804;-</span>step <span style="color: #268bd2;">&#8804;-</span>refl) <span style="color: #859900; font-weight: bold;">where</span> open <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Nat.Properties</span> using (<span style="color: #268bd2;">&#8804;-</span>step)
</pre>
</div>
<p>
This' an example of a â€˜forgetful functorâ€™, keep reading!
</p>

<div class="org-src-container">
<pre class="src src-haskell">[<span style="color: #859900; font-weight: bold;">_</span>]&#8320; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Graph</span>&#8320;
[ n ]&#8320; <span style="color: #268bd2;">=</span> record
    { <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Fin</span> (suc n)                  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8776; {0, 1, ..., n - 1, n}</span>
    ; <span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Fin</span> n                        <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8776; {0, 1, ..., n - 1}</span>
    ; src <span style="color: #268bd2;">=</span> &#955; j <span style="color: #268bd2;">&#8594;</span> ` j
    ; tgt <span style="color: #268bd2;">=</span> &#955; j <span style="color: #268bd2;">&#8594;</span> fsuc j
    }
</pre>
</div>
<p>
That is, we have <code>n+1</code> vertices named <code>0, 1, â€¦, n</code> and <code>n</code> edges named <code>0, 1, â€¦, n-1</code>
with one typing axiom being <code>j : j âŸ¶ (j+1)</code>. Alternatively,
</p>

<div class="org-src-container">
<pre class="src src-haskell">[<span style="color: #859900; font-weight: bold;">_</span>] <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Graph</span>
[ n ] <span style="color: #268bd2;">=</span> record {<span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Fin</span> (suc n) ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> &#955; x y <span style="color: #268bd2;">&#8594;</span> fsuc x <span style="color: #268bd2;">&#8801;</span> ` y }
</pre>
</div>
</div>

<div id="outline-container-org3097e40" class="outline-3">
<h3 id="Types-Require-Casting">Types Require Casting</h3>
<div class="outline-text-3" id="text-Types-Require-Casting">
<p>
However, we must admit that a slight downside of the typed approach
&#x2013;the two-piece definition&#x2013; is now
we may need to use the following â€˜shiftingâ€™ combinators:
They shift, or slide, the edge types.
</p>

<pre class="example">
-- casting
_âŸ«_ : âˆ€{x y yâ€™} â†’  (x âŸ¶ y) â†’ (y â‰¡ yâ€™) â†’ (x âŸ¶ yâ€™)
e âŸ« â‰¡-refl = e

-- Casting leaves the edge the same, only type information changes
â‰…-âŸ« : âˆ€{x y yâ€™} {e : x âŸ¶ y} (yâ‰ˆyâ€™ : y â‰¡ yâ€™) â†’ e â‰… (e âŸ« yâ‰ˆyâ€™)
â‰…-âŸ« â‰¡-refl = â‰…-refl
</pre>

<p>
Such is the cost of using a typed-approach.
</p>

<p>
Even worse, if we use homogeneous equality then weâ€™d have the ghastly operator
</p>
<pre class="example">
â‰¡-âŸ« : âˆ€{x y yâ€™} {e : x âŸ¶ y} (yâ‰ˆyâ€™ : y â‰¡ yâ€™) â†’ e âŸ« yâ‰ˆyâ€™ â‰¡ (â‰¡-subst (Î» Ï‰ â†’ x âŸ¶ Ï‰) yâ‰ˆyâ€™ e)
</pre>

<p>
However, it seems that our development does not even make use of these.
Lucky us! However, it is something to be aware of.
</p>
</div>
</div>

<div id="outline-container-orgbe82e3c" class="outline-3">
<h3 id="Signatures">Signatures</h3>
<div class="outline-text-3" id="text-Signatures">
<p>
A <i>signature</i> consists of â€˜sort symbolsâ€™ and â€˜function symbolsâ€™ each of which is associated source-sorts
and a target-sort &#x2013;essentially it is an interface in the programming sense of the word thereby providing
a lexicon for a language.
A <i>model</i> or <i>algebra</i> of a language is an interpretation of the sort symbols as sets and an interpretation of the
function symbols as functions between those sets; i.e., it is an <i>implementation</i> in programming terms.
Later you may note that instead of sets and functions we may use the objects and morphisms of
a fixed category instead, and so get a model in that category.
</p>

<div class="org-center">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><span class="underline">Math</span></td>
<td class="org-left">â‰…</td>
<td class="org-left"><span class="underline">Coding</span></td>
</tr>

<tr>
<td class="org-left">Signature</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Interface, record type, class</td>
</tr>

<tr>
<td class="org-left">Algebra</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Implementation, instance, object</td>
</tr>

<tr>
<td class="org-left">Language Term</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Syntax</td>
</tr>

<tr>
<td class="org-left">Interpretation</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Semantics, i.e., an implementation</td>
</tr>
</tbody>
</table>
</div>

<p>
Formally, one-sorted signatures are defined:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Vec</span>
  using (<span style="color: #b58900; font-style: italic;">Vec</span>)
  renaming (<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8759;</span><span style="color: #859900; font-weight: bold;">_</span> to <span style="color: #859900; font-weight: bold;">_</span>,,<span style="color: #859900; font-weight: bold;">_</span> ; <span style="color: #b58900; font-style: italic;">[]</span> to nil) <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">, already in use for products :/</span>

<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">one sorted</span>
<span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">Signature</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
    field
     <span style="color: #b58900; font-style: italic;">&#119977;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span>        <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">How many function symbols there are</span>
     ar <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Vec</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #b58900; font-style: italic;">&#119977;</span> <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Their arities: lookup i ar == arity of i-th function symbol</span>

<span style="color: #b58900;">open</span> <span style="color: #b58900; font-style: italic;">Signature</span> &#10627;<span style="color: #268bd2;">...</span>&#10628; <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#119977; now refers to the number of function symbols in a signature</span>
</pre>
</div>

<p>
For example, the signature of monoids consists of a single sort symbol <code>C</code> &#x2013;which can be
interpreted as the carrier of the monoid&#x2013; and two function symbols <code>m , u</code>
&#x2013;which can be interpreted as the monoid multiplication and unit&#x2013; with source-target
sort lists <code>((),C) , ((C,C), C)</code> &#x2014;some would notate this by <code>u :â†’ C , m : C Ã— C â†’ C</code>.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">MonSig</span> <span style="color: #b58900;">:</span> <span style="color: #b58900; font-style: italic;">Signature</span>
<span style="color: #b58900; font-style: italic;">MonSig</span> <span style="color: #268bd2;">=</span> record { <span style="color: #b58900; font-style: italic;">&#119977;</span> <span style="color: #268bd2;">=</span> 2 ; ar <span style="color: #268bd2;">=</span> 0 ,, 2 ,, nil }
<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">unit u : X&#8304; &#8594; X and multiplication m : X&#178; &#8594; X</span>
</pre>
</div>

<p>
Generalising on monoids by typing the multiplication we obtain
the signature of categories which consists of three sort symbols <code>O, A, C</code> &#x2013;which can be
interepreted as objects, arrows, and composable pairs of arrows&#x2013; and four function symbols
<code>â¨¾ , src, tgt, id</code> with source-target sort lists <code>(C,A) , (A,O) , (A,O) , (O,A)</code>
&#x2014;notice that only a language of symbols
has been declared without any properties besides those of typing. If we discard <code>C, â¨¾, id</code> we
then obtain the signature of graphs. Without knowing what categories are, we have seen that their
signatures are similar to both the graph and monoid signatures and so expect their logics to
also be similar. Moreover we now have a few slogans,
\[\color{green}{\text{Categories are precisely typed monoids!}}\]
\[\color{green}{\text{Categories are precisely graphs with a monoidal structure!}}\]
\[\color{green}{\text{Categories are precisely coherently constructive lattices!}}\]
</p>

<p>
( The last one is completely unmotivated from our discussion, but it's a good place for the slogan and
  will be touched on when we look at examples of categories. )
</p>

<p>
A signature can be visualised in the plane by associating a dot for each sort symbol and an arrow
for each function symbol such that the arrow has a tail from each sort in the associated function
symbols source sorts list and the end of the arrow is the target sort of the sort symbol.
That is, a signature can be visualised as a hyper-graph.
</p>

<ul class="org-ul">
<li>A signature whose function symbols each have only one sort symbol for source-sorts is called a
â€˜graph signatureâ€™ since it corresponds to &#x2014;or can be visualised as&#x2014; a graph.</li>

<li>Then a model of a graph (signature) <code>ğ’¢</code> is an interpreation/realisation of the graphâ€™s vertices
as sets and the graphâ€™s edges as functions between said sets.</li>

<li>A model of <code>ğ’¢</code> is nothing more than a graph morphism
<code>ğ’¢ âŸ¶ ğ’®eğ“‰</code>, where <code>ğ’®eğ“‰</code> is the graph with vertices being sets and edges being functions.</li>
</ul>

<p>
Notice that a <code>Graphâ‚€</code> is precisely a model of the graph <code>â€¢ â‡‰ â€¢</code>, which consists of
two vertices and two edges from the first vertex to the second vertex.
We will return to this point ;-)
</p>

<p>
Before we move on, it is important to note that a signature does not capture any
constraints required on the symbols &#x2013;e.g., a monoid is the monoid signature as well
as the constraint that the 2-arity operation is associative and the 0-arity operation is its unit.
More generally, a <i>specification</i> consists of a signature declaring symbols of interest,
along with a set of sentences over it that denote axioms or constraints.
In programming parlance, this is an interface consisting of types and functions
that need to be provided and implemented, along with constraints that are usually documented in comments.
Unsurprisingly, models of specifications also form categories.
</p>
</div>
</div>
</div>

<div id="outline-container-org3a3fa37" class="outline-2">
<h2 id="Cats-but-no-alligators"><i>Cats but no alligators</i></h2>
<div class="outline-text-2" id="text-Cats-but-no-alligators">
<p>
In this section we introduce the notion of a â€˜â€˜poor-manâ€™s categoryâ€™â€™ along with the notion of
structure preserving transformations and structure preserving transformations between such
transformations. The former are called <i>functors</i> and the latter are known as <i>natural transformations</i>
and are considered one of the most important pieces of the fundamentals of category theory;
as such, we discuss them at length.
Afterwards, we relate this section back to our motivating discussion of graphs.
</p>
</div>

<div id="outline-container-orge0ee361" class="outline-3">
<h3 id="Strict-Categories">Strict Categories</h3>
<div class="outline-text-3" id="text-Strict-Categories">
<p>
A category, like a monoid, is a a few types and operations for which some equations hold.
However, to discuss equations a notion of equality is needed and rather than enforce one
outright it is best to let it be given. This is a â€˜setâ€™ in constructive mathematics:
A type with an <code>E</code>-quivalence relation on it &#x2014;also called a <i>setoid</i> or an <code>E</code>-set.
However, then the structure must have a few added axioms: The operations must be congruences,
i.e., preserve the equivalence relation, and structure-preserving maps must also be congruences.
</p>

<p>
For our purposes we will use propositional equality and point-wise propositional equality,
and as such most of the proofs fall out of the fact that propositional equality is an equivalence.
However, this setoid structure becomes a bit of a noise, without providing any real insight for our uses,
and the issues of equivalences will be a distraction from the prime focus.
Instead, for our two cases where we use point-wise propositional,
we will postulate two forms of extensionality. Without question this is not a general approach
&#x2014;then again, our aim is not to develop a library for category theory, which has already been
done so elegantly by Kahl who calls it the <a href="http://relmics.mcmaster.ca/RATH-Agda/RATH-Agda-2.0.0.pdf">RATH-Agda</a> project.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">where</span> <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">An anyonomous module for categorial definitions</span>

 record <span style="color: #b58900; font-style: italic;">Category</span> {i j <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Level</span>} <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> (&#8467;suc (i <span style="color: #268bd2;">&#8845;</span> j)) <span style="color: #859900; font-weight: bold;">where</span>
  <span style="color: #859900; font-weight: bold;">infixr</span> 10 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>
  field
    <span style="color: #b58900; font-style: italic;">Obj</span>      <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> i
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span>     <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> j
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>      <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">C</span>
    assoc    <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #b58900; font-style: italic;">D</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span>}{g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">C</span>} {h <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">D</span>} <span style="color: #268bd2;">&#8594;</span> (f <span style="color: #268bd2;">&#10814;</span> g) <span style="color: #268bd2;">&#10814;</span> h <span style="color: #268bd2;">&#8801;</span> f <span style="color: #268bd2;">&#10814;</span> (g <span style="color: #268bd2;">&#10814;</span> h)
    <span style="color: #b58900; font-style: italic;">Id</span>       <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">A</span>
    leftId   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">&#10814;</span> f <span style="color: #268bd2;">&#8801;</span> f
    rightId  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span>} <span style="color: #268bd2;">&#8594;</span> f <span style="color: #268bd2;">&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">&#8801;</span> f

 open <span style="color: #b58900; font-style: italic;">Category</span> using (<span style="color: #b58900; font-style: italic;">Obj</span>)
 open <span style="color: #b58900; font-style: italic;">Category</span> &#10627;<span style="color: #268bd2;">...</span>&#10628; hiding (<span style="color: #b58900; font-style: italic;">Obj</span>)

 <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Some sugar for times when we must specify the category</span>
 <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8220;colons associate to the right&#8221; ;-)</span>

 arr <span style="color: #268bd2;">=</span> Category._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span>
 syntax arr <span style="color: #b58900; font-style: italic;">&#119966;</span> x y  <span style="color: #268bd2;">=</span>  x <span style="color: #268bd2;">&#10230;</span> y <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8220;ghost colon&#8221;</span>

 cmp <span style="color: #268bd2;">=</span> Category._<span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>
 syntax cmp <span style="color: #b58900; font-style: italic;">&#119966;</span> f g  <span style="color: #268bd2;">=</span>  f <span style="color: #268bd2;">&#10814;</span> g <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8220;ghost colon&#8221;</span>
</pre>
</div>

<p>
However, similar to nearly everything else in this document, we can leave the setoid approach as an exercise
for the reader, which of course has solutions being in the literate source.
</p>

<p>
Moreover, lest youâ€™re not convinced that my usage of extensionality is at all acceptable,
then note that others have used it to simplify their presentations; e.g.,
<a href="http://cs.ioc.ee/~tarmo/papers/jfr14.pdf">Relative monads formalised</a>.
Such â€˜appeal to authorityâ€™ is for the lazy reader who dares not think for him- or her-self,
otherwise one ought to read up on the <a href="https://ncatlab.org/nlab/show/principle+of+equivalence">evils</a>
of using equality instead of equivalence relations so as to understand
<a href="http://www.math.harvard.edu/~mazur/preprints/when_is_one.pdf">when one thing is really another</a>.
</p>

<p>
The diligent reader may be interested to know that Maarten Fokkinga has written a very
<a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">gentle introduction to category theory using the calculational approach</a>; I highly recommend it!
</p>

<p>
Anyhow, in place of strict equality, one uses categorical isomorphism instead.
</p>
<div class="org-src-container">
<pre class="src src-haskell"> open <span style="color: #b58900; font-style: italic;">Category</span> using (<span style="color: #b58900; font-style: italic;">Obj</span>) public

 record <span style="color: #b58900; font-style: italic;">Iso</span> {i} {j} (<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}) (<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>) <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> j <span style="color: #859900; font-weight: bold;">where</span>
   private <span style="color: #859900; font-weight: bold;">instance</span> <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
   field
     to   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span>
     from <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">A</span>
     lid  <span style="color: #b58900; font-style: italic;">:</span> to <span style="color: #268bd2;">&#10814;</span> from <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">Id</span>
     rid  <span style="color: #b58900; font-style: italic;">:</span> from <span style="color: #268bd2;">&#10814;</span> to <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">Id</span>

 syntax <span style="color: #b58900; font-style: italic;">Iso</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8773;</span> <span style="color: #b58900; font-style: italic;">B</span> within <span style="color: #b58900; font-style: italic;">&#119966;</span>
</pre>
</div>

<p>
Interestingly, we shall later encounter a rather large category named
ğ’ğ’¶ğ“‰ possessing the special property of being a <a href="https://ncatlab.org/nlab/show/2-category">â€œ2-Categoryâ€</a>:
It has morphisms between objects, as expected, which are now called â€œ1-morphismsâ€,
and it has morphisms between 1-morphisms, also called â€œ2-morphismsâ€.
</p>

<p>
That is, it has morphisms between morphisms.
</p>

<p>
Above we argued that equality should be deferred in favour of isomorphism
at the morphism level. Hence, in a 2-Category, it is only reasonable to defer
an equation involving objects to be up to isomorphism of 2-morphisms
&#x2014;this is then called an â€œequivalenceâ€.
</p>
<pre class="example">
â„’HS â‰ƒ â„›HS  â‡”  Î£ F âˆ¶ â„’HS âŸ¶ â„›HS â€¢ Î£ G âˆ¶ â„›HS âŸ¶ â„’HS â€¢ F â¨¾ G â‰… G â¨¾ F â‰… Id
</pre>

<p>
Hence when it comes to categories themselves, one usually speaks in terms of
equivalences rather than isomorphisms.
</p>

<p>
For example, let ğ’«ğ’¶ğ“‡ be the supercategory of ğ’®eğ“‰ with morphisms being â€˜partial
functionsâ€™ <code>(A âŸ¶ B) = (A â†’ B + ğŸ™)</code> where the extra element of <code>ğŸ™ = { * }</code> represents
â€˜undefinedâ€™ &#x2014;also known as the <code>Partial</code>, <code>Option</code>, or <code>Maybe</code> monads.  Moreover,
let ğ’«ğ’®â„¯ğ“‰ be the category of sets with an elected point.  Then, <code>ğ’«ğ’¶ğ“‡ â‰ƒ ğ’«ğ’®eğ“‰</code> is
witnessed by <code>(A âŸ¶ B) â†¦ ( (A + ğŸ™, *) âŸ¶ (B + ğŸ™, *) )</code> and conversely
<code>( (A , a) âŸ¶ (B , b) ) â†¦ ( A - a âŸ¶ B - b)</code> where
 <br> <code>X - x â‰¡ Î£ y âˆ¶ X â€¢ Â¬(x â‰¡
y)</code>. Exercise: Work out the remaining details for the equivalence.
</p>
</div>
</div>

<div id="outline-container-org72a540b" class="outline-3">
<h3 id="Familiar-ğ’®â„¯ğ“‰-tings">Familiar <code>ğ’®â„¯ğ“‰</code>-tings</h3>
<div class="outline-text-3" id="text-Familiar-ğ’®â„¯ğ“‰-tings">
<p>
Let us give some elementary examples of the notion of a category to exhibit its ubiquity.
</p>
</div>

<div id="outline-container-org3875cf6" class="outline-4">
<h4 id="ğ’®â„¯ğ“‰'s">ğ’®â„¯ğ“‰'s</h4>
<div class="outline-text-4" id="text-ğ’®â„¯ğ“‰'s">
<p>
The collection of small, say level <code>i</code>, types and functions between them and usual function composition
with usual identity form a category and this is not at all difficult to see:
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #859900; font-weight: bold;">instance</span>
  <span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Category</span> {&#8467;suc i} {i} <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">this is a &#8216;big&#8217; category</span>
  <span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span> {i} <span style="color: #268bd2;">=</span> record {
      <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Set</span> i
    ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> &#955; <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8594;</span> (<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span>)
    ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> &#955; f g <span style="color: #268bd2;">&#8594;</span> (&#955; x <span style="color: #268bd2;">&#8594;</span> g (f x))
    ; assoc <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
    ; <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">=</span> &#955; x <span style="color: #268bd2;">&#8594;</span> x
    ; leftId <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
    ; rightId <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
    }
</pre>
</div>
<p>
Sadly, this category is traditionally used to motivate constructions in arbitrary categories
and as such people usually think of objects in an arbitrary category as nothing more than
sets with extra datum &#x2014;which is completely false.
</p>

<p>
For example, the category <code>Div</code> consists of objects <i>and</i> arrows both being numbers â„•
and there is an arrow \(k : m â†’ n\) precisely when <code>k Ã— m = n</code>, so that an arrow is a
constructive witness that \(m\) divides \(n\). Notice that besides â„•, no sets nor functions
were involved in the making of this useful number-theoretic category.
</p>
</div>
</div>

<div id="outline-container-org20d552f" class="outline-4">
<h4 id="Sets-are-trivial-categories">Sets are trivial categories</h4>
<div class="outline-text-4" id="text-Sets-are-trivial-categories">
<p>
Recall that a type, or set, is nothing more than a specified collection of values.
</p>

<p>
Every set is also a category: There is a formal syntactic object associated with each element, the only morphisms are (formal)
identities, and composition is constantly a syntactic identity.
Some define a set to be a category with only identity morphisms; also called a
â€˜discrete categoryâ€™ when one wants to distance themself from set theory ;)
&#x2014;less loosely, a discrete category over a type <code>S</code> has <code>Obj = S</code> and <code>(x âŸ¶ y) = (x â‰¡ y)</code>,
where the equivalence is classical, having two possible members <i>true</i> or <i>false</i>.
</p>

<p>
Discrete categories are quite an important space for <a href="http://homotopytypetheory.org/">hott</a> people &#x2026;
thatâ€™s right, attractive people are interested in these things.
</p>

<p>
Observe that all arrows are invertible! &#x2014;due to the symmetry of equality.
Categories with this property are known as <i>groupoids</i>.
</p>
</div>
</div>

<div id="outline-container-orgde07e52" class="outline-4">
<h4 id="Categories-are-typed-monoids">Categories are typed monoids</h4>
<div class="outline-text-4" id="text-Categories-are-typed-monoids">
<p>
Recall that a monoid <code>(M, âŠ•, e)</code> is a type <code>M</code> with an associative operation <code>âŠ• : M Ã— M â†’ M</code>
that has a unit <code>e</code>.
</p>

<p>
Every monoid is also a category: There is one object, call it <code>â˜…</code>, the morphisms are the monoid
elements, and composition is the monoid operation.
&#x2014;less loosely, for a monoid <code>(M, âŠ•, e)</code> we take <code>Obj = {â˜…} , _âŸ¶_ = M</code>.
</p>

<p>
In fact, some would define a monoid to be a one-object category!
&#x2013;I'm looking at you <a href="https://books.google.ca/books/about/Categories_Allegories.html?id=fCSJRegkKdoC&amp;printsec=frontcover&amp;source=kp_read_button&amp;redir_esc=y#v=onepage&amp;q&amp;f=false">Freyd &amp; Scedrov</a> =)
</p>
</div>
</div>

<div id="outline-container-orgbeab04a" class="outline-4">
<h4 id="Categories-are-coherently-preordered-sets">Categories are coherently preordered sets</h4>
<div class="outline-text-4" id="text-Categories-are-coherently-preordered-sets">
<p>
<a href="http://www.cs.utexas.edu/~EWD/ewd11xx/EWD1102.PDF">Recall</a> that a preordered set, or preset, is a type <code>P</code> with a relation <code>â‰¤</code> on
it that satisfies <i>indirect inequality from above</i>:
\[
  âˆ€ x , y â€¢\qquad x â‰¤ y \quadâ‡”\quad (âˆ€ z â€¢\; y â‰¤ z â‡’ x â‰¤ z)
\]
Equivalently, if it satisfies <i>indirect equality from below</i>:
\[ âˆ€ x , y â€¢\qquad x â‰¤ y \quadâ‡”\quad (âˆ€ z â€¢\; z â‰¤ x â‡’ z â‰¤ y) \]
If we also have \(âˆ€ x , y â€¢\; x â‰¤ y \,âˆ§\, y â‰¤ x \;â‡’\; x = y\),
then we say <code>(P, â‰¤)</code> is a â€˜posetâ€™ or an â€˜ordered setâ€™.
</p>

<p>
Every (pre)ordered set is also a category:
The objects are the elements,
the morphisms are the order-relations,
identities are the relfexitivity of <code>â‰¤</code>,
and composition is transitivity of <code>â‰¤</code>.
To see this more clearly, suppose you have a group
\((M, âŠ•, \_{}â»Â¹, e)\) and you define \(x â‰¤ y \;â‡”\; (âˆƒ m : M â€¢\; m âŠ• x = y)\)
then the this is a preorder whose induced category has a morphism
\(m : x â†’ y\) precicely when \(m âŠ• x = y\)
&#x2013;now sit down and define the remaining categorical structure of this
â€˜constructiveâ€™ preorder associated to the group.
</p>

<p>
Traditionally, classically, the relation <code>â‰¤</code> is precicely a function <code>P Ã— P âŸ¶ ğ”¹ = {true, flase}</code>
and thus there is at-most one morphism between any two objects
&#x2013;consequently, categories with this property are called <i>poset categories</i>.
</p>

<p>
In the constructive setting, the relation <code>â‰¤</code> is typed <code>P Ã— P â†’ Set</code> and then
for a preset <code>(P, â‰¤)</code> we take <code>Obj = P, _âŸ¶_ = a â‰¤ b</code> and insist
on â€˜proof-irrelevanceâ€™ <code>âˆ€ {a b} (p q : a â‰¤ b) â†’ p â‰¡ q</code> so that there is at most one morphism
between any two objects.
The restriction is not needed if we were using actual categories-with-setoids since then we would
<i>define</i> morphism equality to be  <br>
<code>((a, b, p) â‰ˆ (aâ€™, bâ€™, q) )  =  (a â‰¡ aâ€™  Ã—  b â‰¡ bâ€™)</code>.
</p>

<p>
Observe that in the case we have a poset, every isomorphism is an equality:
\[
  âˆ€ x, y â€¢\qquad x â‰… y â‡” x â‰¡ y
\]
Categories with this property are called <i>skeletal</i>.
Again, hott people like this; so much so, that they want it, more-or-less, to be a
<a href="http://arxiv.org/abs/1302.4731">foundational axiom</a>!
</p>

<p>
Poset categories are a wonderful and natural motivator for many constructions and definitions in
category theory. This idea is so broad-reaching that it would not be an exaggeration to think of
<a href="http://www.cs.nott.ac.uk/~psarb2/papers/abstract.html#CatTheory">categories as coherently constructive lattices</a>!
</p>
</div>
</div>

<div id="outline-container-orgd39b60a" class="outline-4">
<h4 id="Groupoids">Groupoids</h4>
<div class="outline-text-4" id="text-Groupoids">
<p>
Equivalence relations are relations that are symmetric, reflexive, and transitive.
Alternatively, they are preorder categories where every morphism is invertible &#x2014;this is the
symmetry property. But categories whose morphisms are invertible are groupoids!
</p>

<p>
Hence, groupoids can be thought of as generalized equivalence relations.
Better yet, as â€œconstructiveâ€ equivalence relations: there might be more than one morphism/construction
witnessing the equivalence of two items.
</p>

<p>
Some insist that a <i>true</i> â€˜setâ€™ is a type endowed with an equivalence relation, that is a setoid.
However, since groupoids generalise equivalence relations, others might insist on a true set to be
a "groupoid". However, in the constructive setting of dependent-type theory, these notions
coincide!
</p>
</div>
</div>

<div id="outline-container-org1f67498" class="outline-4">
<h4 id="Rule-of-Thumb">Rule of Thumb</h4>
<div class="outline-text-4" id="text-Rule-of-Thumb">
<p>
Itâ€™s been said that the aforementioned categories should be consulted whenever one learns a new
concept of category theory.
Indeed, these examples show that a category is a generalisation of a system of processes,
a system of compositionality, and an ordered system.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orga5bf64e" class="outline-2">
<h2 id="Endowing-Structure-with-Functors"><i>Endowing Structure with Functors</i></h2>
<div class="outline-text-2" id="text-Endowing-Structure-with-Functors">
<p>
Now the notion of structure-preserving maps, for categories, is just that of graphs
but with attention to the algebraic portions as well.
</p>

<div class="org-src-container">
<pre class="src src-haskell"> record <span style="color: #b58900; font-style: italic;">Functor</span> {i j k l} (<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}) (<span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {k} {l})
  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> (&#8467;suc (i <span style="color: #268bd2;">&#8845;</span> j <span style="color: #268bd2;">&#8845;</span> k <span style="color: #268bd2;">&#8845;</span> l)) <span style="color: #859900; font-weight: bold;">where</span>
  private
    <span style="color: #859900; font-weight: bold;">instance</span>
      <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ;  <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
      <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ;  <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">&#8242;</span>  <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>
  field
    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Usual graph homomorphism structure: An object map, with morphism preservation</span>
    obj   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>
    mor   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#10230;</span> y <span style="color: #268bd2;">&#8594;</span> obj x <span style="color: #268bd2;">&#10230;</span> obj y
    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Interaction with new algebraic structure: Preservation of identities &amp; composition</span>
    id    <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">&#8594;</span> mor (<span style="color: #b58900; font-style: italic;">Id</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">=</span> x}) <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">Id</span>       <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">identities preservation</span>
    comp  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y z} {f <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y} {g <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#10230;</span> z} <span style="color: #268bd2;">&#8594;</span> mor (f <span style="color: #268bd2;">&#10814;</span> g) <span style="color: #268bd2;">&#8801;</span> mor f <span style="color: #268bd2;">&#10814;</span> mor g

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Aliases for readability</span>
  functor_preserves<span style="color: #268bd2;">-</span>composition <span style="color: #268bd2;">=</span> comp
  functor_preserves<span style="color: #268bd2;">-</span>identities  <span style="color: #268bd2;">=</span> id

 open <span style="color: #b58900; font-style: italic;">Functor</span> public hiding (id ; comp)
</pre>
</div>

<p>
For a functor <code>F</code>, it is common practice to denote both <code>obj F</code> and <code>mor F</code> by <code>F</code> and this is usually
not an issue since we can use type inference to deduce which is meant. However, in the Agda formalization
we will continue to use the names <code>mor , obj</code>. Incidentally in the Haskell community, <code>mor</code>
is known as <code>fmap</code> but we shall avoid that name or risk asymmetry in the definition of
a functor, as is the case in Haskell which turns out to be pragmatically useful.
</p>

<p>
A functor can be thought of as endowing an object with some form of structure
&#x2014;since categories are intrinsically structureless in category theory&#x2014;
and so the morphism component of a functor can be thought of as preserving relations:
<code>f : a âŸ¶ b â‡’ F f : F a âŸ¶ F b</code> can be read as, â€˜â€˜if <code>a</code> is related to <code>b</code> (as witnessed by <code>f</code>)
then their structured images are also related (as witness by <code>F f</code>)â€™â€™.
Recall the category <code>Div</code> for constructive divisibility relationships ;-)
</p>
</div>

<div id="outline-container-orgfc45a93" class="outline-3">
<h3 id="Functor-Examples">Examples</h3>
<div class="outline-text-3" id="text-Functor-Examples">
<p>
A functor among monoids &#x2013;construed as categories&#x2013; is just a monoid homomorphism;
i.e., an identity and multiplication preserving function of the carriers.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><i>(M, âŠ•, e) âŸ¶ (N, âŠ—, d)</i></td>
</tr>

<tr>
<td class="org-left">=</td>
<td class="org-left"><i>Î£ h âˆ¶ M â†’ N â€¢ âˆ€ x,y â€¢ h(x âŠ• y) = h x âŠ— h y âˆ§ h e = d</i></td>
</tr>
</tbody>
</table>

<p>
By induction, <code>h</code> preserves all finite âŠ•-multiplication and, more generally,
functors preserve finite compositions:
\[ F (fâ‚€ â¨¾ fâ‚ â¨¾ â‹¯ â¨¾ fâ‚™) \;\;=\;\; F\,fâ‚€ â¨¾ F\,fâ‚ â¨¾ â‹¯ â¨¾ F\,fâ‚™ \]
Cool beans :-)
</p>

<p>
In the same way, sit down and check your understanding!
</p>
<ul class="org-ul">
<li>A functor among discrete categories is just a function of the associated sets.</li>
<li>A functor among poset categories is an order-preserving function.</li>
</ul>

<p>
Two examples of functors from a poset (category) to a monoid (category):
</p>

<ul class="org-ul">
<li><code>monus : (â„•, â‰¤) âŸ¶ (â„•,+, 0)</code> is a functor defined on morphisms by
\[ i â‰¤ j \quadâ‡’\quad \mathsf{monus}(i,j) â‰” j - i\]
Then the functor laws become  <code>i - i = 0</code> and <code>(k - j) + (j - i) = k - i</code>.</li>

<li><code>div : (â„•âº, â‰¤) â†’ (â„š, Ã—, 1)</code> is defined on morphisms by
\[i â‰¤ j \quadâ‡’\quad \mathsf{div}(i,j) â‰” j / i\]
The functor laws become <code>i / i = 1</code> and <code>(k / j) Ã— (j / i) = k / i</code>.</li>
</ul>

<p>
Hey, these two seem alarmingly similar! What gives!
Well, theyâ€™re both functors from posets to monoids ;)
Also, they are instances of â€˜residuated po-monoidsâ€™.
Non-commutative monoids may have not have a general inverse operation,
but instead might have left- and right- inverse operations known as residuals
&#x2014;weâ€™ll mention this word again when discussing adjunctions and are
categorically seen as kan extensions.
Alternatively, theyâ€™re are instances of <a href="http://link.springer.com.libaccess.lib.mcmaster.ca/article/10.1007/s10773-004-7710-7">â€˜(Kopka) Difference-posetsâ€™</a>.
</p>


<p>
For more examples of categories, we will need to reason
by extensionality &#x2013;two things are â€˜equalâ€™ when they have
equivalent properties &#x2026; recall Leibniz and his
<a href="https://en.wikipedia.org/wiki/Identity_of_indiscernibles">law of indiscernibles</a> ;p
</p>
</div>
</div>
</div>
<div id="outline-container-org19f0cd4" class="outline-2">
<h2 id="The-four-postulates-of-the-apocalypse"><i>The four postulates of the apocalypse</i></h2>
<div class="outline-text-2" id="text-The-four-postulates-of-the-apocalypse">
<p>
Categories have objects and morphisms between them, functors are morphisms between categories,
and then we can go up another level and consider morphisms between functors.
These â€˜level 2 morphismsâ€™ are pretty cool, so letâ€™s touch on them briefly.
</p>

<p>
Recall that a poset ordering is extended to (possibly non-monotone) functions \(f , g\) pointwise
\[f \overset{.}{â‰¤} g \quad\iff\quad (âˆ€ x â€¢\; f\, x \,â‰¤\, g\, x)\]
As such, with posets as our guide, we extend the notion of â€˜morphism between functorsâ€™
to be a â€˜witnessâ€™ of these orderings \(Î· : âˆ€ {X} â†’ F\, X âŸ¶ G\, X\)
&#x2013;this is a dependent type, note that the second arrow notates category morphisms, whereas
the first acts as a separator from the implicit parameter \(X\); sometimes one sees \(Î·_X\)
for each component/instance of such an operation.
</p>

<div class="org-center">
<p>
\(\require{AMScd}\)
</p>
\begin{CD}
\color{navy}{F\, A} @>\color{fuchsia}{Î·_A}>>      \color{teal}{G\, A}    \\
@V\color{navy}{F\, f}VV    \!=                    @VV\color{teal}{G\, f}V \\
\color{navy}{F\, B} @>>\color{fuchsia}{Î·_B}>      \color{teal}{G\, B}
\end{CD}
</div>

<p>
However, then for any morphism \(f : A âŸ¶ B\) we have two ways to get from \(F\, A\) to \(G\, B\) via
<code>F f â¨¾ Î· {B}</code> and <code>Î· {A} â¨¾ G f</code> and rather than choose one or the other, we request that they
are identical &#x2014;similar to the case of associativity.
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #b58900; font-style: italic;">NatTrans</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j i&#8217; j&#8217;}  &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j} &#10628; &#10627; <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i&#8217;} {j&#8217;} &#10628;
            (<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> (j&#8217; <span style="color: #268bd2;">&#8845;</span> i <span style="color: #268bd2;">&#8845;</span> j)
 <span style="color: #b58900; font-style: italic;">NatTrans</span> &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> &#10628; &#10627; <span style="color: #b58900; font-style: italic;">&#119967;</span> &#10628; <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">=</span>
   <span style="color: #b58900; font-style: italic;">&#931;</span> &#951; <span style="color: #268bd2;">&#8758;</span> (<span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">&#8594;</span> (obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">X</span>) <span style="color: #268bd2;">&#10230;</span> (obj <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">X</span>))
       <span style="color: #268bd2;">&#8226;</span> (<span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span>} <span style="color: #268bd2;">&#8594;</span> mor <span style="color: #b58900; font-style: italic;">F</span> f <span style="color: #268bd2;">&#10814;</span> &#951; {<span style="color: #b58900; font-style: italic;">B</span>} <span style="color: #268bd2;">&#8801;</span> &#951; {<span style="color: #b58900; font-style: italic;">A</span>} <span style="color: #268bd2;">&#10814;</span> mor <span style="color: #b58900; font-style: italic;">G</span> f)
</pre>
</div>
<p>
The naturality condition is remembered by placing the target component <code>Î· {B}</code> <i>after</i>
lifting <code>f</code> using the <i>source</i> functor <code>F</code>;
likewise placing the source component <i>before</i> applying the target functor.
</p>

<p>
Another way to remember it:
<code>Î· : F âŸ¶Ì‡ G</code> starts at <code>F</code> and ends at <code>G</code>, so the naturality also starts with <code>F</code> and ends
with <code>G</code>; i.e., <code>F f â¨¾ Î· {B} = Î· {A} â¨¾ G f</code> :-)
</p>

<p>
It is at this junction that aforementioned problem with our definition
of category comes to light: Function equality is extensional by definition
and as such we cannot prove it.
Right now we have two function-like structures for which we will postulate a
form of extensionality,
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">function extensionality</span>
 postulate extensionality <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j} {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> i} {<span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> j}
                              {f g <span style="color: #b58900; font-style: italic;">:</span> (a <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span> a}
                          <span style="color: #268bd2;">&#8594;</span> (<span style="color: #268bd2;">&#8704;</span> {a} <span style="color: #268bd2;">&#8594;</span> f a <span style="color: #268bd2;">&#8801;</span> g a) <span style="color: #268bd2;">&#8594;</span> f <span style="color: #268bd2;">&#8801;</span> g

 <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">functor extensionality</span>
 postulate funcext <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j k l} &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j} &#10628; &#10627; <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {k} {l} &#10628;
                       {<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>}
                     <span style="color: #268bd2;">&#8594;</span> (oeq <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {o} <span style="color: #268bd2;">&#8594;</span> obj <span style="color: #b58900; font-style: italic;">F</span> o <span style="color: #268bd2;">&#8801;</span> obj <span style="color: #b58900; font-style: italic;">G</span> o)
                     <span style="color: #268bd2;">&#8594;</span> (<span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">Y</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">Y</span>}
                        <span style="color: #268bd2;">&#8594;</span> mor <span style="color: #b58900; font-style: italic;">G</span> f  <span style="color: #268bd2;">&#8801;</span>  <span style="color: #268bd2;">&#8801;-</span>subst&#8322; (Category._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) oeq oeq (mor <span style="color: #b58900; font-style: italic;">F</span> f))
                     <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">G</span>

 <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">graph map extensionality</span>
 postulate graphmapext <span style="color: #b58900; font-style: italic;">:</span> {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span> } {f g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">GraphMap</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span>}
                       <span style="color: #268bd2;">&#8594;</span> (veq <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {v} <span style="color: #268bd2;">&#8594;</span> ver f v <span style="color: #268bd2;">&#8801;</span> ver g v)
                       <span style="color: #268bd2;">&#8594;</span> (<span style="color: #268bd2;">&#8704;</span> {x y} {e <span style="color: #b58900; font-style: italic;">:</span> Graph._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">G</span> x y}
                          <span style="color: #268bd2;">&#8594;</span> edge g e <span style="color: #268bd2;">&#8801;</span> <span style="color: #268bd2;">&#8801;-</span>subst&#8322; (Graph._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">H</span>) veq veq (edge f e))
                       <span style="color: #268bd2;">&#8594;</span> f <span style="color: #268bd2;">&#8801;</span> g

 <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">natural transformation extensionality</span>
 postulate nattransext <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j i&#8217; j&#8217;} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j} } {<span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i&#8217;} {j&#8217;} }
                         {<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>} (&#951; &#947; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">NatTrans</span> <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">G</span>)
                       <span style="color: #268bd2;">&#8594;</span> (<span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">X</span>} <span style="color: #268bd2;">&#8594;</span> proj&#8321; &#951; {<span style="color: #b58900; font-style: italic;">X</span>} <span style="color: #268bd2;">&#8801;</span> proj&#8321; &#947; {<span style="color: #b58900; font-style: italic;">X</span>})
                       <span style="color: #268bd2;">&#8594;</span> &#951; <span style="color: #268bd2;">&#8801;</span> &#947;
</pre>
</div>

<p>
Natural transformations are too cool to end discussing so briefly
and so we go on to discuss their usage is mathematics later on.
</p>
</div>

<div id="outline-container-org8f237d9" class="outline-3">
<h3 id="A-very-big-ğ’ğ’¶ğ“‰">A very big <code>ğ’ğ’¶ğ“‰</code></h3>
<div class="outline-text-3" id="text-A-very-big-ğ’ğ’¶ğ“‰">
<p>
With the notions of categories, functors, and extensionality in-hand we can now discus the
notion of the category of small categories and the category of small graphs.
Afterwards we give another example of a functor that says how every category can be
construed as a graph.
</p>

<p>
First the category of <i>smaller</i> categories,
</p>
<blockquote>
<p>
<code>ğ’ğ’¶ğ“‰</code> is a category of kind <code>(â„“suc m, â„“suc m)</code>, where <code>m = i âŠ j</code>, and its objects
are categories of kind <code>(i , j)</code> and so it is not an object of itself.
</p>

<p>
Thank-you Russel and friends!
</p>

<p>
( You may proceed to snicker at the paradoxical and size issues encountered
  by those who use set theory.
  &#x2014;Then again, Iâ€™ve never actually learned, nor even attempted to learn,
  any â€˜â€˜formal set theoryâ€™â€™;
  what I do know of set theory is usually couched in the language of type theory;
  I heart <a href="https://www.springer.com/gp/book/9780387941158">LADM</a>!
)
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #859900; font-weight: bold;">instance</span>
  <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Category</span> {&#8467;suc (i <span style="color: #268bd2;">&#8845;</span> j)} {&#8467;suc (i <span style="color: #268bd2;">&#8845;</span> j)}
  <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span> {i} {j} <span style="color: #268bd2;">=</span> record {
      <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}
    ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Functor</span>
    ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> &#955; {<span style="color: #b58900; font-style: italic;">&#119966;</span>} {<span style="color: #b58900; font-style: italic;">&#119967;</span>} {<span style="color: #b58900; font-style: italic;">&#8496;</span>} <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#8594;</span>
        <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #859900; font-weight: bold;">instance</span>
                   <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
                   <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ; <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>
                   <span style="color: #b58900; font-style: italic;">&#8496;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ; <span style="color: #b58900; font-style: italic;">&#8496;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#8496;</span>
        <span style="color: #859900; font-weight: bold;">in</span> record
        { obj  <span style="color: #268bd2;">=</span>  obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#10814;</span> obj <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">this compositon lives in &#119982;e&#120009;</span>
        ; mor  <span style="color: #268bd2;">=</span>  mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#10814;</span> mor <span style="color: #b58900; font-style: italic;">G</span>
        ; id   <span style="color: #268bd2;">=</span>  &#955; {x} <span style="color: #268bd2;">&#8594;</span> begin
              (mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#10814;</span> mor <span style="color: #b58900; font-style: italic;">G</span>) (<span style="color: #b58900; font-style: italic;">Id</span> &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> &#10628; {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">=</span> x})
            <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #2aa198;">"definition of function composition"</span> &#10217;<span style="color: #268bd2;">&#8242;</span>
              mor <span style="color: #b58900; font-style: italic;">G</span> (mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">Id</span>)
            <span style="color: #268bd2;">&#8801;</span>&#10216; functor <span style="color: #b58900; font-style: italic;">F</span> preserves<span style="color: #268bd2;">-</span>identities even<span style="color: #268bd2;">-</span>under (mor <span style="color: #b58900; font-style: italic;">G</span>) &#10217;
              mor <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">Id</span>
            <span style="color: #268bd2;">&#8801;</span>&#10216; functor <span style="color: #b58900; font-style: italic;">G</span> preserves<span style="color: #268bd2;">-</span>identities &#10217;
              <span style="color: #b58900; font-style: italic;">Id</span>
            <span style="color: #268bd2;">&#8718;</span>
        ; comp <span style="color: #268bd2;">=</span> &#955; {x y z f g} <span style="color: #268bd2;">&#8594;</span>
             begin
               (mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#10814;</span> mor <span style="color: #b58900; font-style: italic;">G</span>) (f <span style="color: #268bd2;">&#10814;</span> g)
            <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #2aa198;">"definition of function composition"</span> &#10217;<span style="color: #268bd2;">&#8242;</span>
               mor <span style="color: #b58900; font-style: italic;">G</span> (mor <span style="color: #b58900; font-style: italic;">F</span> (f <span style="color: #268bd2;">&#10814;</span> g))
             <span style="color: #268bd2;">&#8801;</span>&#10216; functor <span style="color: #b58900; font-style: italic;">F</span> preserves<span style="color: #268bd2;">-</span>composition even<span style="color: #268bd2;">-</span>under mor <span style="color: #b58900; font-style: italic;">G</span> &#10217;
               mor <span style="color: #b58900; font-style: italic;">G</span> (mor <span style="color: #b58900; font-style: italic;">F</span> f <span style="color: #268bd2;">&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span> g)
             <span style="color: #268bd2;">&#8801;</span>&#10216; functor <span style="color: #b58900; font-style: italic;">G</span> preserves<span style="color: #268bd2;">-</span>composition &#10217;
               (mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#10814;</span> mor <span style="color: #b58900; font-style: italic;">G</span>) f <span style="color: #268bd2;">&#10814;</span> (mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#10814;</span> mor <span style="color: #b58900; font-style: italic;">G</span>) g
             <span style="color: #268bd2;">&#8718;</span>
        }
    ; assoc    <span style="color: #268bd2;">=</span>  &#955; {a b c d f g h} <span style="color: #268bd2;">&#8594;</span> funcext <span style="color: #268bd2;">&#8801;-</span>refl <span style="color: #268bd2;">&#8801;-</span>refl
    ; <span style="color: #b58900; font-style: italic;">Id</span>       <span style="color: #268bd2;">=</span>  record { obj <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Id</span> ; mor <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Id</span> ; id <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl ; comp <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl }
    ; leftId   <span style="color: #268bd2;">=</span>  funcext <span style="color: #268bd2;">&#8801;-</span>refl <span style="color: #268bd2;">&#8801;-</span>refl
    ; rightId  <span style="color: #268bd2;">=</span>  funcext <span style="color: #268bd2;">&#8801;-</span>refl <span style="color: #268bd2;">&#8801;-</span>refl
    }
</pre>
</div>

<p>
Some things to note,
</p>

<ul class="org-ul">
<li>First off: <code>functor F preserves-composition even-under mor G</code> is a real line of code!
It consists of actual function calls and is merely an alias for
<code>â‰¡-cong (mor G) (mor F)</code> but it sure is far more readable than this form!</li>

<li><p>
We could have written <code>id = â‰¡-cong (mor G) (id F) âŸ¨â‰¡â‰¡âŸ© id G</code>,
but this is not terribly clear what is going on.
Especially since we introduced categories not too long ago,
we choose to elaborate the detail.
</p>

<p>
Likewise, <code>comp = (â‰¡-cong (mor G) (comp F)) âŸ¨â‰¡â‰¡âŸ© (comp G)</code>.
</p></li>

<li><code>assoc</code> is trivial since function composition is, by definition, associative.
Likewise <code>leftId, rightId</code> hold since functional identity is, by definition, unit of function composition.</li>
</ul>
</div>
</div>
<div id="outline-container-org60f6a6e" class="outline-3">
<h3 id="ğ’¢ğ“‡ğ’¶ğ“…ğ’½"><code>ğ’¢ğ“‡ğ’¶ğ“…ğ’½</code></h3>
<div class="outline-text-3" id="text-ğ’¢ğ“‡ğ’¶ğ“…ğ’½">
<p>
In a nearly identical way, just ignoring the algebraic datum, we can show that
<code>Graph</code>'s with <code>GraphMap</code>'s form a graph
</p>
<pre class="example">
  ğ’¢ğ“‡ğ’¶ğ“…ğ’½ : Category
  ğ’¢ğ“‡ğ’¶ğ“…ğ’½ = {! exercise !}
</pre>
</div>
</div>

<div id="outline-container-org1f631ef" class="outline-3">
<h3 id="ğ’ğ’¶ğ“‰-'s-are-ğ’¢ğ“‡ğ’¶ğ“…ğ’½-'s"><code>ğ’ğ’¶ğ“‰</code>'s are <code>ğ’¢ğ“‡ğ’¶ğ“…ğ’½</code>'s</h3>
<div class="outline-text-3" id="text-ğ’ğ’¶ğ“‰-'s-are-ğ’¢ğ“‡ğ’¶ğ“…ğ’½-'s">
<div class="org-center">
<p>
<i>Forgive and forget: The ğ’°nderlying functor.</i>
</p>
</div>

<p>
Letâ€™s formalise what we meant earlier when we said graphs are categories
but ignoring the algebraic data.
</p>

<p>
Given a category, we ignore the algebraic structure to obtain a graph,
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Graph</span>
 <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">=</span> record { <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> Category._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> }
</pre>
</div>

<p>
Likewise, given a functor we â€˜forgetâ€™ the property that the map of morphisms needs to preserve all
finite compositions to obtain a graph map:
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">:</span> {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">&#119967;</span>
 <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">=</span> record { ver <span style="color: #268bd2;">=</span> obj <span style="color: #b58900; font-style: italic;">F</span> ; edge <span style="color: #268bd2;">=</span> mor <span style="color: #b58900; font-style: italic;">F</span> }
</pre>
</div>
<p>
This says that <code>ğ’°â‚</code> turns <code>ver, edge</code> into <code>obj , mor</code>
--<code>ğ’°â‚ â¨¾ ver  â‰¡ obj</code> and <code>ğ’°â‚ â¨¾ edge â‰¡ mor</code>&#x2013; reassuring us that <code>ğ’°â‚</code> acts
as a bridge between the graph structures: <code>ver , edge</code> of graphs and
<code>obj , mor</code> of categories.
</p>

<p>
Putting this together, we obtain a functor.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Underlying/forgetful functor: Every category is a graph</span>
 <span style="color: #b58900; font-style: italic;">&#119984;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span>
 <span style="color: #b58900; font-style: italic;">&#119984;</span> <span style="color: #268bd2;">=</span> record { obj <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; ; mor <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; ; id <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl ; comp <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl }
</pre>
</div>
<p>
We forget about the extra algebraic structure of a category and of a functor to
arrive at a graph and graph-map, clearly --<code>â‰¡-refl</code>&#x2013; such â€˜forgetfullnessâ€™ preserves identities
and composition since it does not affect them at all!
</p>

<p>
Those familiar with category theory may exclaim that just as I have mentioned
the names â€˜underlying functorâ€™ and â€˜forgetful functorâ€™ I ought to mention
â€˜stripping functorâ€™ as it is just as valid since it brings about connotations of
â€˜stripping awayâ€™ extra structure.
Iâ€™m assuming the latter is less popular due to its usage for
poor mathematical jokes and puns.
</p>

<p>
Before we move on, the curious might wonder if â€˜â€˜categories are graphsâ€™â€™
then what is the analgoue to â€˜â€˜\(X\) are hypergraphsâ€™â€™,
it is <a href="http://arxiv.org/PS_cache/math/pdf/0305/0305049v1.pdf#page=178">multicategories</a>.
</p>

<p>
Now the remainder of these notes is to build-up the material
needed to realise the notion of â€˜freeâ€™ which is, in some sense,
<i>the best-possible approximate inverse</i> to â€˜forgetfulâ€™
&#x2013;however, forgetting is clearly not invertible since it can easily
confuse two categories as the same graph!
</p>
</div>
</div>
</div>

<div id="outline-container-org6256803" class="outline-2">
<h2 id="How-natural-is-naturality"><i>How natural is naturality?</i></h2>
<div class="outline-text-2" id="text-How-natural-is-naturality">
<p>
Recall, that a natural transformation \(Î· : F \natTo G\) is a family
\(âˆ€ \{X \,:\, \Obj ğ’\} \,â†’\, F\, X âŸ¶ G\, X\) that satisfies the naturality condition:
\(âˆ€ \{A \; B\} \{f \,:\, A âŸ¶ B\} \,â†’\, F f â¨¾ Î· {B} \;â‰¡\; Î· {A} â¨¾ G f\).
</p>

<ul class="org-ul">
<li>In the type of Î·, note that the first <i>show</i> arrow â€˜â†’â€™ acts as a separator from the
the âˆ€-quantified variable \(X\), whereas the second <i>longer</i> arrow â€˜âŸ¶â€™ denotes the
morphism type in the category ğ’.</li>

<li>We will freely interchange the informal mathematical rendition \((Î·_x : F\, X â†’ G\, X)_{x âˆˆ \Obj ğ’}\)
with the aforementioned formal Agda forms <code>âˆ€{X : Obj ğ’} â†’ F X â†’ G â†’ X</code> and invocation <code>Î· {X}</code>.</li>
</ul>

<div class="org-center">
<p>
\(\require{AMScd}\)
</p>
\begin{CD}
\color{navy}{F\, A} @>\color{fuchsia}{Î·_A}>>      \color{teal}{G\, A}    \\
@V\color{navy}{F\, f}VV    \!=                    @VV\color{teal}{G\, f}V \\
\color{navy}{F\, B} @>>\color{fuchsia}{Î·_B}>      \color{teal}{G\, B}
\end{CD}
</div>
<p>
Let us look at this from a few different
angles; in particular, <a href="http://mathoverflow.net/questions/56938/what-does-the-adjective-natural-actually-mean/56956">what does the adjective â€˜naturalâ€™ actually mean?</a>
Itâ€™s been discussed on many forums and we collect a few of the key points here.
</p>
</div>

<div id="outline-container-org4559df9" class="outline-3">
<h3 id="Identification-of-possible-paths-contraction-of-choices">Identification of possible paths &#x2014;contraction of choices</h3>
<div class="outline-text-3" id="text-Identification-of-possible-paths-contraction-of-choices">
<p>
Given two functors \(F , G\), for any object \(~x\) we obtain two objects \(F\, x\, , \, G\, x\) and so a morphism
from \(F\) to \(G\) ought to map such \(F\,x\) to \(G\, x\). That is, a morphsim of functors is a family  <br>
\(Î· \,:\, âˆ€ \{x : \Obj ğ’\} \,â†’\, F \,x âŸ¶ G \,x\). Now for any \(f : a â†’ b\) there are two ways to form a morphism
\(F\, a â†’ G\, b\): \(F f â¨¾ Î· \{b\}\) and \(Î· \{a\} â¨¾ G\, f\). Rather than make a choice each time we want such
a morphism, we eliminate the choice all together by insisting that they are identical.
This is the naturality condition.
</p>

<p>
This is similar to when we are given three morphisms \(f : a â†’ b , g : b â†’ c , h : c â†’ d\),
then there are two ways to form a morphism \(a â†’ d\); namely \((f â¨¾ g) â¨¾ h\) and \(f â¨¾ (g â¨¾ h)\).
Rather than make a choice each time we want such a morphism, we eliminate the choice all together
by insisting that they are identical. This is the associativity condition for categories.
</p>

<p>
Notice that if thereâ€™s no morphism \(F\, x âŸ¶ G\, x\) for some \(x\), they by definition thereâ€™s no
possible natural transformation \(F \natTo G\).
</p>
</div>
</div>

<div id="outline-container-org12572c4" class="outline-3">
<h3 id="No-Choice-free-will-is-only-an-illusion">No Choice &#x2013;free will is only an illusion</h3>
<div class="outline-text-3" id="text-No-Choice-free-will-is-only-an-illusion">
\begin{align*}
     & \quad\text{the natural $X$}
\\ = & \quad\text{the $X$ which requires no arbitrary choices}
\\ = & \quad\text{the canonical/standard $X$}
\end{align*}

<p>
That is,
</p>
\begin{align*}
     & \quad \text{it is a natural construction/choice}
\\ = & \quad \text{distinct people would arrive at the same construction;}
\\   & \quad \text{ (no arbitrary choice or cleverness needed) }
\\ = & \quad \text{ there is actually no choice, i.e., only one possiility, }
\\   & \quad \text{ and so two people are expected to arrive at the same â€˜choiceâ€™}
\end{align*}

<p>
Thus, if a construction every involves having to decide between distinct routes, then chances are
the result is not formally natural.
Sometimes this â€˜inutionâ€™ is developed from working in a field for some time;
sometimes it just â€œfeelâ€" natural.
</p>

<p>
<a href="http://math.stackexchange.com/questions/939404/do-natural-transformations-make-god-given-precise?rq=1">Some would even say</a>: <i>Natural = God-given</i>.
</p>
</div>
</div>

<div id="outline-container-org60f32ca" class="outline-3">
<h3 id="Natural-means-polymorphic-without-type-inspection">Natural means polymorphic without type inspection</h3>
<div class="outline-text-3" id="text-Natural-means-polymorphic-without-type-inspection">
<p>
A natural transformation can be thought of as a polymorphic function
<code>âˆ€ {X} â†’ F X âŸ¶ G X</code> <i>where</i> we restrict ourselves to avoid inspecting any <code>X</code>.
</p>

<ul class="org-ul">
<li>Recall that a <code>mono</code>-morphic operation makes no use of type variables in its signature,
whereas a <code>poly</code>-morphic operation uses type variables in its signature.</li>

<li>For example, in C# one can ask if one type <code>is</code> a subclass of another thereby
obtaining specific information, whereas there is no such mechanism in Haskell.</li>
</ul>

<p>
Inspecting type parameters or not leads to the distinction of ad hoc plymorphism vs. parametric
polymorphism &#x2014;the later is the kind of polymorphism employed in functional language like Haskell
and friends and so such functions are natural transformations by default!
<a href="http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf">Theorems for free!</a>
</p>

<p>
For example,
</p>
<pre class="example">
-- Let ğ’¦ x y â‰” Id {x} for morphisms, and ğ’¦ x y â‰” x for objects.

size : âˆ€ {X} â†’ List X â†’ ğ’¦ â„• X
size [xâ‚, â€¦, xâ‚™] = n
</pre>
<p>
is a polymorphic function and so naturality follows and is easily shown &#x2013;show it dear reader!
So we have always have
\[List\; f \;â¨¾\; size \quad=\quad size\]
Since <code>ğ’¦ â„• f = Id</code>, then by extensionality: <code>size : List âŸ¶Ì‡ ğ’¦</code>.
</p>
<p>
On the other hand, the polymorphic function
</p>
<pre class="example">
whyme : âˆ€ {X} â†’ List X â†’ ğ’¦ Int X
whyme {X} [xâ‚,â€¦,xâ‚™] = If X = â„• then 1729 else n
</pre>
<p>
is not natural: The needed equation <code>F f â¨¾ Î· {B} = Î· {A} â¨¾ G f</code>
for any <code>f : A â†’ B</code> breaks as witnessed by
<code>f = (Î» x â†’ 0) : â„ â†’ â„•</code> and any list with length <code>n â‰  1729</code>,
and this is easily shown &#x2013;do so!
</p>
<p>
One might exclaim, <i>hey! this only works â€™cuz youâ€™re using Ramanujanâ€™s taxi-cab number!</i>
<i>1729 is the smallest number expressible as a sum of 2 cubes in 2 ways:</i>
<i>\(1729 = 12Â³ + 1Â³ = 10Â³ + 9 Â³\).</i> I assure you that this is not the reason that naturality breaks,
and I commend you on your keen observation.
</p>

<p>
Notice that it is natural if we exclude the type inspected, â„•.
That is, if we only consider \(f : A â†’ B\) with \(A â‰  â„• â‰  B\).
In general, is it the case that a transformation can be made natural by excluding
the types that were inspected?
</p>

<p>
Before we move on, observe that a solution in \(h\) to the absorptive-equation \(F f â¨¾ h = h\)
is precisely a natural transformation from \(F\) to the aforementioned â€˜diagonal functorâ€™:
\[F f â¨¾ h \;=\; h \qquadâ‡”\qquad âˆƒ X : Obj \;â€¢\; h âˆˆ F \overset{.}{âŸ¶} ğ’¦ X ~\]
</p>

<p>
In particular, due to the constant-fusion property \(g \,â¨¾\, ğ’¦\, e \;=\; ğ’¦\, e\), we have that
\[âˆ€ \{F\} \{X\} \{e \,:\, X\} \;â†’\; (ğ’¦\, e) \,âˆˆ\, F \overset{.}{âŸ¶} ğ’¦\, X \]
Is the converse also true? If \(h âˆˆ F âŸ¶Ì‡ ğ’¦ X\) then \(h \,=\, ğ’¦\, e\) for some \(e\)?
</p>
</div>
</div>

<div id="outline-container-org9ebe71a" class="outline-3">
<h3 id="Natural-means-no-reference-to-types">Natural means no reference to types</h3>
<div class="outline-text-3" id="text-Natural-means-no-reference-to-types">
<p>
The idea that a natural transformation cannot make reference to the type variable at all can be
seen by yet another example.
</p>

<pre class="example">
  data ğŸ™ : Set where â˜… : ğŸ™

  -- Choice function: For any type X, it yields an argument of that type.
  postulate Îµ : (X : Set) â†’ X

  nay : âˆ€ {X} â†’ X â†’ X
  nay {X} _ = Îµ X
</pre>

<p>
Now naturality \(\Id \, f â¨¾ nay_B \;=\; nay_A â¨¾ \Id \, f\) breaks as witnessed by
\(f \;=\; (Î» _ â†’ Îµâ„• + 1) \;:\; ğŸ™ â†’ â„•\) &#x2013;and provided \(Îµâ„• â‰  0\), otherwise
we could use an \(f\) with no fix points.
</p>

<p>
From this we may hazard the following:
If we have natural transformations \(Î·áµ¢ \,:\, âˆ€ {X : Objáµ¢} â†’\, F X \overset{.}{âŸ¶} G X\)
where the \(Objáµ¢\) partition the objects available &#x2014; i.e., \(Obj \;=\; Î£ i \,â€¢\, Objáµ¢\) &#x2014;
then the transformation \(Î·_{(i, X)} \;=\; Î·áµ¢\) is generally unnatural since it clearly makes choices,
for each partition.
</p>
</div>
</div>

<div id="outline-container-orgc996d29" class="outline-3">
<h3 id="Natural-means-uniformly-and-simultaneously-defined">Natural means uniformly and simultaneously defined</h3>
<div class="outline-text-3" id="text-Natural-means-uniformly-and-simultaneously-defined">
<p>
A family of morphisms is <i>natural in x</i> precisely when it is defined
<i>simultaneously</i> for all <i>x</i> &#x2014;there is no inspection of some particular <i>x</i> here and there,
no, it is uniform! With this view, the naturality condition is thought of as a â€˜simultaneityâ€™
condition. <a href="https://www.google.ca/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8&amp;client=ubuntu#q=general%20theory%20of%20natural%20equivalences">Rephrasing GToNE</a>.
</p>

<p>
The idea of naturality as uniformly-definable is pursued by <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.2336&amp;rep=rep1&amp;type=pdf">Hodges and Shelah</a>.
</p>
</div>
</div>

<div id="outline-container-org1be2b0a" class="outline-3">
<h3 id="Naturality-is-restructure-modify-commutativity">Naturality is restructure-modify commutativity</h3>
<div class="outline-text-3" id="text-Naturality-is-restructure-modify-commutativity">
<p>
Recall that a functor can be thought of as endowing an object with structure.
Then a transformation can be thought of as a restructuring operation and naturality means
that it doesnâ€™t matter whether we restructure or modify first, as long as we do both.
</p>
</div>
</div>

<div id="outline-container-org82df0f6" class="outline-3">
<h3 id="Natural-means-obvious">Natural means obvious</h3>
<div class="outline-text-3" id="text-Natural-means-obvious">
<p>
It may help to think of <i>thereâ€™s a natural transformation from F to G</i> to mean
<i>thereâ€™s an obvious/standard/canconical way to transform F structure into G structure</i>.
</p>

<p>
Likewise, <i>F is naturally isomorphic to G</i> may be read <i>F is obviously isomorphic to G</i>.
For example, <b>TODO</b> seq-pair or pair-seq ;-)
</p>

<p>
Sometimes we can show â€˜â€˜F X is isomorphic to G X, if we make a choice dependent on Xâ€™â€™
and so the isomorphism is not obvious, since a choice must be made.
</p>
</div>
</div>

<div id="outline-container-org3461c18" class="outline-3">
<h3 id="Naturality-is-promotion">Naturality is promotion</h3>
<div class="outline-text-3" id="text-Naturality-is-promotion">
<ul class="org-ul">
<li>I think Richard Bird refers to the naturality condition as a promotion law where the functors
involved are thought of as (list) constructions.</li>

<li>The nomenclature is used <a href="https://www.cs.ox.ac.uk/files/3378/PRG56.pdf">to express the idea than operation on a compound structure
can be â€˜promotedâ€™ into its components.</a></li>

<li>Reading <code>F f â¨¾ Î· {B} = Î· {A} â¨¾ G f</code> from left to right:
Mapping \(f\) over a complicated structure then handling the result
<i>is the same as</i>
handling the complex datum then mapping \(f\) over the result.

<ul class="org-ul">
<li>`Handling' can be thought of as `processing' or as `reshaping'.</li>
</ul></li>
</ul>

<p>
Lists give many examples of natural transformations by considering
<a href="https://link.springer.com/chapter/10.1007/3-540-51305-1_24">a categorical approach to the theory of lists.</a>
</p>
</div>
</div>

<div id="outline-container-orgd94143b" class="outline-3">
<h3 id="Naturality-as-a-rewrite-rule">Naturality as a rewrite rule</h3>
<div class="outline-text-3" id="text-Naturality-as-a-rewrite-rule">
<p>
The naturality condition can be seen as a rewrite rule that letâ€™s us replace a complicated or
inefficient side with a simplier or more efficient yet equivalent expression.
I think I first learned this view of equations at the insistence of
<a href="https://www.amazon.com/Algebra-Programming-Prentice-hall-International-Computer/dp/013507245X">Richard Bird and Oege de Moor</a>
&#x2013;whose text can be found <a href="http://themattchan.com/docs/algprog.pdf">here</a>, albeit the legitimacy of the link may be suspect.
</p>

<p>
For example, recall the ğ’¦onstant functor now construed only as a polymorphic binary operation:
</p>
<pre class="example">
_âŸª_    :  âˆ€{A B : Set} â†’ A â†’ B â†’ A
a âŸª b  =  a
</pre>

<p>
The above is a constant time operation, whereas the next two are linear time operations; i.e.,
they take <code>n</code> steps to compute, where <code>n</code> is the length of the given list.
</p>

<pre class="example">
-- This' map for List's; i.e., the mor of the List functor
map    : âˆ€ {A B : Set} (f : A â†’ B) â†’ List A â†’ List B
map f []         =  []
map f (x âˆ· xs)  =  f x âˆ· map f xs

-- Interpret syntax `xâ‚€âˆ·â‹¯âˆ·xâ‚™â‚‹â‚` semantically as `xâ‚€ âŠ• â‹¯ âŠ• xâ‚™â‚‹â‚`, where âŠ• = cons.
fold  : âˆ€ {A B : Set} (cons : A â†’ B â†’ B) (nil : B) â†’ List A â†’ B
fold cons nil [] = nil
fold cons nil (x âˆ· xs) = cons x (fold cons nil xs)
</pre>

<p>
By <i>Theorems for Free</i>, or a simple proof, we have that <code>fold</code> is a natural
transformation \(List \overset{.}{â†’} \Id\):
\[ List\; f \;â¨¾\; fold \; cons_B \; nil_B \qquad=\qquad fold \; cons_A \; nil_A \;â¨¾\; f \]
Note that here we are ranging over objects \(X\) equipped with \(nil_X : X, \; cons_X : X â†’ X â†’ X\);
as such the equation is not valid when this is not the case.
</p>

<p>
Now we map compute,
</p>
<pre class="example">
postulate A B : Set
postulate nil-B : B
postulate f : A â†’ B -- possibly expensive operation

head  :  List B â†’ B
head  =  fold _âŸª_ nil-B

compute  :  List A â†’ B
compute  =  map f  â¨¾  head
</pre>

<p>
That is,
</p>
<pre class="example">
  compute [xâ‚€, â€¦, xâ‚™â‚‹â‚]
= head (map f [xâ‚€, â€¦, xâ‚™â‚‹â‚])
= head [f xâ‚€, â€¦, f xâ‚™â‚‹â‚]
= f xâ‚€  âŸª  f xâ‚ âŸª â‹¯ âŸª â‹¯ f xâ‚™â‚‹â‚ âŸª nil-B
= f xâ‚€
</pre>

<p>
However this approach performs the potentially expensive operation \(f\) a total of
\(n = \text{â€œlength of inputâ€}\) times! In spite of that, it only needs the first element of
the list and performs the operation only once! Indeed, by the naturality of <code>fold</code> we have
an equivalent, and more efficient, formulation:
</p>
<pre class="example">
compute  =  head  â¨¾  f
</pre>

<p>
This operation only performs the potentially costly <code>f</code> once!
</p>

<p>
A more concrete and realistic example is to produce an efficient version of the function
that produces the <code>average xs = div (sum xs, length xs)</code> of a list of numbers: This operation
traverses the input list twice, yet we can keep track of the length as we sum-along the list
to obtain an implementation that traverses the list only once!
</p>

<p>
<a href="https://scss.tcd.ie/publications/tech-reports/reports.99/TCD-CS-1999-74.pdf">Indeed</a>,
</p>
<pre class="example">
div : â„• Ã— â„• â†’ â„•
div (0, 0) = 0
div (m, n) = m Ã· n

average     :  List â„• â†’ â„•
average xs  =  div (fold _âŠ•_ ğŸ˜ xs)
  where  ğŸ˜ = (0 , 0)
         _âŠ•_  : â„• â†’ (â„• Ã— â„•) â†’ â„•
         a âŠ• (b , n) = (a + b , n + 1)
</pre>
</div>
</div>

<div id="outline-container-orga90281d" class="outline-3">
<h3 id="Naturality-is-just-model-morphism">Naturality is just model morphism</h3>
<div class="outline-text-3" id="text-Naturality-is-just-model-morphism">
<p>
Given two functors \(F , G : ğ’ âŸ¶ ğ’Ÿ\) let us construe them as only graph homomorphisms.
Then each is a model of the graph \(ğ’°â‚€ \; ğ’\) &#x2014;each intereprets the nodes and edges of <code>ğ’°â‚€ ğ’</code> as
actual objects and morphisms of ğ’Ÿ&#x2014; and a natrual transformation is then nothing
more than a morphism of models.
</p>
</div>
</div>

<div id="outline-container-orge6cbf68" class="outline-3">
<h3 id="Naturality-yields-pattern-matching">Naturality yields pattern matching</h3>
<div class="outline-text-3" id="text-Naturality-yields-pattern-matching">
<p>
In the setting of types and functions, <code>Î· : F âŸ¶Ì‡ G</code> means we have <code>Î· (F f x) = G f (Î· x)</code>
which when read left-to-right says that <code>Î·</code> is defined by pattern-matching on its argument
to obtain something of the form <code>F f x</code> then it is defined recursively by examining <code>x</code> and then
applying <code>G f</code> to the result &#x2014;of course thereâ€™s some base case <code>F</code> definitions as well.
</p>

<p>
Alternatively, the input to <code>Î·</code> is of the form <code>F â€¦</code> and its
output is of the form <code>G â€¦</code> &#x2013;mind blown!
</p>

<p>
For example, I want to define a transformation \(\mathsf{List} âŸ¶Ì‡ \mathsf{List}\).
</p>
<ol class="org-ol">
<li>So let me suppose the input is of the shape \(\List \, f\, x\), more concretely
it is of the shape
 <br> <code>[f xâ‚€, f xâ‚, â€¦, f xâ‚™â‚‹â‚]</code> &#x2013;for arbitrary \(f : A â†’ B\).</li>
<li>Then the output shape must be \(\List \, f\, (Î· \, x)\), more concretely
it is of the shape  <br> <code>[f yâ‚€, f yâ‚, â€¦, f yâ‚˜â‚‹â‚]</code> where \(y \,=\, Î·\,x\).</li>
<li><p>
So my <i>only</i> choices are \(y : \List A\) and \(m : â„•\)
</p>

<p>
Here are some possibilities and the resulting Î·:
</p>
<dl class="org-dl">
<dt>\(y, m = x, n\)</dt><dd>Identity function</dd>
<dt>\(y, m = x, 0\)</dt><dd>Constantly empty list <code>[]</code> function</dd>
<dt>\(y, m = x, 1\)</dt><dd>The first element, â€˜headâ€™, function</dd>
<dt>\(y, m = x, k\)</dt><dd>The first \(k < n\) elements function</dd>
<dt>\(m = n\) with \(yáµ¢ = xâ‚™â‚‹áµ¢\)</dt><dd>List reversal function</dd>
<dt>\(y, m = \mathsf{reverse}(x), k\)</dt><dd>The last \(k < n\) elements, in reverse, function
<ul class="org-ul">
<li>Here we applied an already known natural transformation
and indeed the composition of naturally transformation is itself natural.</li>
</ul></dd>
</dl></li>
</ol>
</div>
</div>

<div id="outline-container-org76b170b" class="outline-3">
<h3 id="Naturality-Examples">Examples</h3>
<div class="outline-text-3" id="text-Naturality-Examples">
<dl class="org-dl">
<dt>Pointwise Monotonicity</dt><dd>A functor among poset categories is an order-preserving function and a natural transformation
\(f \natTo g\) is a proof that \(f \overset{.}{â‰¤} g\) pointwise: \(âˆ€ x \,â€¢\, f\, x \;â‰¤\; g\, x\)
&#x2014;all the other pieces for a natural
transformation are automatic from the definition of begin a poset category.</dd>

<dt>conjugation</dt><dd><p>
A functor among monoids &#x2013;construed as categories&#x2013; is just a monoid homomorphism:
</p>
\begin{align*}
           & (M, âŠ•, e) âŸ¶ (N, âŠ—, d)
{{{newline}}} â‰… \quad & Î£ h âˆ¶ M â†’ N â€¢ âˆ€ \{x \, y \} â€¢\; h(x âŠ• y) = h x âŠ— h y \lands h e = d
\end{align*}
<p>
A natural transformation <code>(f, prf) âŸ¶ (g, prfâ€™)</code> is a point \(n : N\) with
\(âˆ€ x âˆ¶ M \;â€¢\; f x âŠ— n \,=\, n âŠ— g x\), a so-called â€˜conjugationâ€™ by \(n\) that takes \(f\) to \(g\).
</p></dd>

<dt>fold</dt><dd><p>
Recall from the introduction \(ğ’°(S, âŠ•, e) \;=\; S\) was the underlying functor from monoids to sets.
</p>

<p>
Let \(ğ’° Ã— ğ’°\) be the functor that for objects \(M \;â†¦\; ğ’°\, M \,Ã—\, ğ’°\, M\) and for morphisms
\(h \;â†¦\; Î» (x,y) â†’ (h\, x, h\, y)\). Then the monoid multiplication (of each monoid) is a natural
transformation \(ğ’° Ã— ğ’° \natTo ğ’°\), where naturality says that for any monoid homomorphism \(h\), the
application of \(ğ’°\, h\) to the (monoid) multiplication of two elements is the same as the
(monoid) multiplication of the \(ğ’°\, h\) images of the two elements,
and this is evident from the homomorphism condition.
</p>

<p>
Extending to finite products, \(â„’ \;â‰”\; (Î£ n âˆ¶ â„• â€¢ âˆ i âˆ¶ 1..n â€¢ ğ’°)\), the natural transformation
\(â„’ \natTo ğ’°\) is usually called <i>fold, reduce, or cata</i> and <code>â„’</code> is known as the
<i>free monoid functor</i> with notations \(A* \;=\; \List A \;=\; â„’\, A\).
</p>

<p>
Loosely put,
</p>
<pre class="example">
    â„’â‚€    :  Monoid â†’ Set
    â„’â‚€ M  =  Î£ n âˆ¶ â„• â€¢ âˆ i : 1..n â€¢ ğ’° M   -- finite sequences of elements from M

    â„’â‚ : âˆ€ {M N : Monoid} â†’ (M âŸ¶ N) â†’ â„’â‚€ M â†’ â„’â‚€ N
    â„’â‚ (h , prf) = Î» (n , xâ‚, â€¦, xâ‚™) â†’ (n , h xâ‚ , â€¦ , h xâ‚™)

    fold : âˆ€ {M : Monoid} â†’ â„’â‚€ M â†’ ğ’°â‚€ M
    fold {(M, âŠ•, e)} = Î» (n , xâ‚, â€¦, xâ‚™) â†’ xâ‚ âŠ• â‹¯ âŠ• xâ‚™
</pre>

<p>
&#x2013;The reader would pause to consider implementing this formally using Agda's <code>Data.Fin</code> and <code>Data.Vec</code> ;-)&#x2013;
</p>

<p>
Now for any monoid homomorphism <code>h</code>, applying induction, yields
</p>
<pre class="example">
    hâ‚€(xâ‚ âŠ• â‹¯ âŠ• xâ‚™)  =  hâ‚€ xâ‚ âŠ• â‹¯ âŠ• hâ‚€ xâ‚™  where  hâ‚€ = ğ’° (hâ‚€, prf) = ğ’° h
</pre>
<p>
Which is easily seen to be just naturality &#x2013; if we use backwards composition \(f â¨¾ g \;=\; g âˆ˜ f\) &#x2013;
</p>
<pre class="example">
    ğ’° h âˆ˜ fold {M}  =  fold {N} âˆ˜ â„’ h
</pre>
<p>
Woah!
</p></dd>

<dt>Every operation in any multisorted algebraic structure gives a natural transformation</dt><dd><p>
This is mentioned in the <a href="http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf">Barr and Wells' <i>Category Theory for Computing Science</i> text</a>, citing
Linton, 1969a-b.
</p>

<p>
For example, <code>src, tgt</code> &#x2014;from the graph signature&#x2014; give natural transformations
\(V \natTo E\) from the vertex functor to the edge functor &#x2026; keep reading ;)
</p></dd>

<dt>Representability</dt><dd><p>
Recall that \(V(G)\) is essentially \(â„™â‚€ âŸ¶ G\) where
\(â„™â‚™\) is the graph of \(n\) edges on \(n+1\) vertices named \(0..n\) with typing \(i \,:\, i-1 âŸ¶ i\),
which I like to call <i>the path graph of length n</i>; and in particular \(â„™â‚€\) is the graph of
just one dot, called 0, and no edges. &#x2014;Earlier I used the notation <code>[n]</code>, but Iâ€™m using \(â„™\) since
I like the view point of â„™aths.
</p>

<p>
What does it mean to say that <i>V(G) is essentially â„™â‚€ âŸ¶ G</i>?
</p>

<p>
It means that the vertices functor
&#x2013; \(ğ’± \;:\; ğ’¢ğ“‡ğ’¶ğ“…ğ’½ âŸ¶ ğ’®â„¯ğ“‰\) that takes objects \(G â†¦ V(G)\) and morphisms \(h â†¦ \mathsf{ver}\, h\) &#x2013;
can be â€˜representedâ€™ as the Hom functor \((â„™â‚€ âŸ¶ \_{})\), that is to say
\[ğ’± \quadâ‰…\quad (â„™â‚€ âŸ¶ \_{}) \;\mathsf{within \; Func} \; ğ’¢ğ“‡ğ’¶ğ“…ğ’½ \; ğ’®â„¯ğ“‰\]
--<code>Func</code>-tor categories will be defined in the next section!&#x2013;
</p>

<p>
Notice that we arrived at this expression by
â€˜eta-reducingâ€™ the phrase <i>V(G) is essentially â„™â‚€ âŸ¶ G</i>! ;)
</p>

<p>
More generally, we have the functor \(â„™â‚™ âŸ¶ \_{}\) which yields all paths of length \(n\)
for a given graph.
</p>

<p>
Observe &#x2013;i.e., show&#x2013; that we also have an edges functor.
</p></dd>
</dl>
</div>
</div>
</div>
<div id="outline-container-orgec6d96c" class="outline-2">
<h2 id="Functor-Categories"><i>Functor Categories</i></h2>
<div class="outline-text-2" id="text-Functor-Categories">
<p>
With a notion of morphisms between functors, one is led inexorably to ask
whether functors as objects and natural transformations as morphisms constitute
a category?
They do!
However, we leave their definition to the reader &#x2014;as usual, if the reader is ever so desperate
for solutions, they can be found as comments in the unruliness that is the source file.
</p>
<pre class="example">
 instance
  Func       :  âˆ€ {i j iâ€™ jâ€™} (ğ’ : Category {i} {j}) (ğ’Ÿ : Category {iâ€™} {jâ€™}) â†’ Category _
  Func ğ’ ğ’Ÿ  =  {! exercise !}
</pre>

<ul class="org-ul">
<li>A hint: The identity natural transformation is the obvious way to get from \(F\, X\) to \(F\, X\),
for any \(X\) given \(F\) &#x2014;well the only way to do so, without assuming anything else about the
functor \(F\), is simply \(\Id_{F X}\). This is the â€˜naturalâ€™ choice, any other choice would be
â€˜unnaturalâ€™ as it would require some â€˜clevernessâ€™.</li>

<li>Another hint: The obvious way to define \(Î· â¨¾ Î³\) to get \(F\, X âŸ¶ H\, X\) from
\(F\, X âŸ¶ G\, X âŸ¶ H\, X\) is composition of morphisms in the category!
That is, pointwise composition. Nothing â€˜cleverâ€™, just using the obvious candidates!</li>
</ul>

<p>
This is a good exercise as it will show you that there is an identity functor and that composition of functors
is again a functor. Consequently, functors are in abundance: Given any two, we can form [possibly] new ones by composition.
</p>

<p>
It is a common construction that when a type \(Y\) is endowed with some structure, then we can endow
the function space \(X â†’ Y\), where \(X\) is any type, with the same structure and we do so
â€˜pointwiseâ€™. This idea is formalised by functor categories.
Alternatively, one can say we have â€˜categorifiedâ€™ the idea; where
<i>categorification</i> is the process of replacing types and functions with categories and
functors and possibly adding some coherence laws.
</p>

<p>
There are people who like to make a show about how â€˜bigâ€™ ğ’ğ’¶ğ“‰ or <code>Func ğ’ ğ““</code> are;
these people adhere to something called â€˜set theoryâ€™ which is essentialy type theory but
ignoring types, loosely put they work only with the datatype
</p>
<pre class="example">
data SET : Set where
  Elem : âˆ€ {A : Set} â†’ A â†’ SET
</pre>
<p>
Such heathens delegate types-of-types into â€˜classesâ€™ of â€˜smallâ€™ and â€˜bigâ€™ sets and itâ€™s not
uniform enough for me.
Anyhow, such people would say that functor categories â€˜â€˜cannot be constructed (as sets)â€™â€™ unless
one of the categories involved is â€˜â€˜smallâ€™â€™. Such shenanigans is ignored due to the hierarchy of
types we are using :-)
</p>

<p>
We must admit that at times the usage of a single type, a â€˜uni-typed theoryâ€™ if you will can be
used when one wants to relise types in an extrinsic fashion rather than think of data as
intrinsically typed &#x2013;E.g., graphs with <code>src, tgt</code> <i>then</i> deriving a notion of â€˜typeâ€™ with <code>_âŸ¶_</code>.
Everything has its place &#x2026; nonetheless, I prefer (multi)typed settings!
</p>
</div>

<div id="outline-container-org9914bee" class="outline-3">
<h3 id="FunctorCats-Examples">Examples</h3>
<div class="outline-text-3" id="text-FunctorCats-Examples">
</div>

<div id="outline-container-org5710b4f" class="outline-4">
<h4 id="All-Categories-are-Functor-Categories">All Categories are Functor Categories</h4>
<div class="outline-text-4" id="text-All-Categories-are-Functor-Categories">
<p>
Let <code>ğŸ™ â‰” [ â€¢ ]</code> be the discrete category of one object (and only the identity arrow on it).
</p>

<p>
Then <code>ğ’ â‰… Func ğŸ™ ğ’</code>.
</p>
</div>
</div>

<div id="outline-container-org09e74c1" class="outline-4">
<h4 id="Powers-of-Categories-are-Functor-Categories">Powers of Categories are Functor Categories</h4>
<div class="outline-text-4" id="text-Powers-of-Categories-are-Functor-Categories">
<p>
Let <code>ğŸšâ‚€ â‰” [â€¢ â€¢]</code> be the discrete category of two objects.
  Then the <i>ğ’-squared</i> category can be defined <code>ğ’ âŠ— ğ’ âˆ¶â‰… Func ğŸšâ‚€ ğ’</code>:
  This category essentially consists of pairs of ğ’-objects with pairs of ğ’-arrows
  between them.
</p>

<p>
The subscript 0 is commonly used for matters associated with objects and
the name <code>ğŸšâ‚€</code> is suggestive of the category of 2 objects only.
</p>

<p>
More generally, if ğ’© is the discrete category of \(n\) objects, then
the <i>n</i>-fold product category is defined by
<code>(âˆ i âˆ¶ 1..n â€¢ ğ’) âˆ¶â‰… Func ğ’© ğ’</code>.
</p>

<p>
These are also commonly denoted \(ğ’^2\) and \(ğ’^ğ’©\) since they are essentially
products, and more generally <code>Func ğ’³ ğ’´</code> is also denoted ğ’´<sup>ğ’³</sup> and referred.
</p>
</div>
</div>

<div id="outline-container-org1850dbb" class="outline-4">
<h4 id="Arrow-Categories">Arrow Categories</h4>
<div class="outline-text-4" id="text-Arrow-Categories">
<p>
We can add an arrow to <code>ğŸšâ‚€</code> to obtain another category&#x2026;
</p>

<p>
Let <code>ğŸš â‰” â€¢ âŸ¶ â€¢</code> be the category of two objects, call them 0 and 1, with one arrow between them.
  Then a functor <code>ğŸš âŸ¶ ğ’</code> is precisely a morphism of ğ’ and a natural transformation
<code>f âŸ¶ g</code> boils down to just a pair of morphisms <code>(h,k)</code> with <code>h â¨¾ g = f â¨¾ k</code>.
</p>

<p>
Hence, the <i>arrow category of ğ’</i> is \(ğ’^ğŸš \;â‰…\; ğ’^â†’ \;â‰…\; \mathsf{Func}\, ğŸš ğ’\);
which is essentially the category with objects being ğ’-morphisms and morphisms being <i>commutative squares</i>.
</p>

<p>
Notice that a functor can be used to
</p>
<ul class="org-ul">
<li><i>select</i> two arbitrary ğ’ objects &#x2013;if it's source is ğŸšâ‚€</li>
<li><i>select</i> two arbitrary ğ’ objects with a ğ’ arrow between them &#x2013;if it's source is ğŸš</li>
<li><i>select</i> an arbitrary ğ’ arrow &#x2013;if it's source is ğŸš</li>
</ul>

<p>
Likewise, a natural transformation can be used to <i>select</i> a commutative diagram.
</p>
</div>
</div>

<div id="outline-container-org0f42bf1" class="outline-4">
<h4 id="Understand-ğ’-by-looking-at-Functor-Categories">Understand ğ’ by looking at Functor Categories</h4>
<div class="outline-text-4" id="text-Understand-ğ’-by-looking-at-Functor-Categories">
<p>
It is a common heuristic that when one suspects the <i>possibility</i> of a category <code>ğ’</code>, then one
can make <i>probes</i> to discover its structure. The objects are just functors <code>ğŸ™ âŸ¶ ğ’</code> and the
morphisms are just functors <code>ğŸš âŸ¶ ğ’</code>.
</p>
</div>
</div>

<div id="outline-container-org7108144" class="outline-4">
<h4 id="Presheaves-delegating-work-to-ğ’®â„¯ğ“‰">Presheaves &#x2013; delegating work to ğ’®â„¯ğ“‰</h4>
<div class="outline-text-4" id="text-Presheaves-delegating-work-to-ğ’®â„¯ğ“‰">
<p>
The <i>category of presheaves of ğ’</i> is the category <code>PSh ğ’ â‰” Func (ğ’ áµ’áµ–) ğ’®eğ“‰</code>.
</p>

<p>
This is a pretty awesome category since it allows nearly all constructions in ğ’®â„¯ğ“‰ to be
realised! Such as subsets, truth values, and even powersets! All these extra goodies make it
a â€˜toposâ€™ aka â€˜power allegoryâ€™ &#x2014;the first is a category that has all finite limits and
a notion of powerset while the second, besides the power part, looks like a totally different beast;
the exhilaration!
</p>
</div>
</div>

<div id="outline-container-orgb5fb3fd" class="outline-4">
<h4 id="Slice-Categories">Slice Categories</h4>
<div class="outline-text-4" id="text-Slice-Categories">
<p>
The <i>slice category of ğ’ over B : Obj ğ’</i> is the category <code>ğ’ / B â‰” Î£ F âˆ¶ Func ğŸš ğ’ â€¢ (F 1 = B)</code>.
</p>

<p>
Essentially it is the category of objects being ğ’-morphisms with target \(B\)
and morphisms \(f âŸ¶ g\) being \((h,k)\) with \(h â¨¾ g = f â¨¾ k\) but a natural choice for
\(k : B âŸ¶ B\) is \(\Id_B\) and so we can use morphism type
\((f âŸ¶â€™ g) \;â‰”\; Î£ h : \src f âŸ¶ \src g \;â€¢\; h â¨¾ g = f\).
</p>

<p>
This is seen by the observation \[(h, k) \;âˆˆ\; f âŸ¶ g \qquadâ‡”\qquad h \;âˆˆ\; (f â¨¾ k) âŸ¶â€™ g\]
Of course a formal justification is obtained by showing
\[\_{}âŸ¶\_{} \quadâ‰…\quad \_{}âŸ¶â€™\_{} \quad \mathsf{within \; Func }\; (ğ’ áµ’áµ– âŠ— ğ’) ğ’®eğ“‰ \]
&#x2026;which I have not done and so may be spouting gibberish!
</p>

<p>
Just as the type <code>Î£ x âˆ¶ X â€¢ P x</code> can be included in the type <code>X</code>, by forgetting the second
component, so too the category <code>Î£ F âˆ¶ ğŸš âŸ¶ ğ’ â€¢ F 1 â‰ˆ B</code> can be included into the category
ğ’ and we say it is a <i>subcategory</i> of ğ’.
</p>

<p>
The notation <code>Î£ o âˆ¶ Obj ğ’ â€¢ P o</code> defines the subcategory of ğ’ obtained by deleting
all objects not satisfying predicate <code>P</code> and deleting all morphisms incident to such objects; i.e.,
it is the category ğ’Ÿ with
\[ \Obj ğ’Ÿ \quadâ‰¡\quad Î£ o âˆ¶ \Obj ğ’ \,â€¢\, P o
   \qquad\text{ and }\qquad
   (o , prf) âŸ¶_ğ’Ÿ (o' , prf') \quadâ‰¡\quad o âŸ¶_ğ’ o'
\]
This is the largest/best/universal subcategory of ğ’ whose objects satisfy \(P\).
 <br> Formalise this via a universal property ;)
</p>
</div>
</div>

<div id="outline-container-org402f4da" class="outline-4">
<h4 id="Slices-of-ğ’®eğ“‰-are-Functor-Categories">Slices of <code>ğ’®eğ“‰</code> are Functor Categories</h4>
<div class="outline-text-4" id="text-Slices-of-ğ’®eğ“‰-are-Functor-Categories">
<p>
\[ \Func \; S \; ğ’®eğ“‰  \qquadâ‰…\qquad  ğ’®eğ“‰ / S \]
Where S in the left is construed as a discrete category and in the right
is construed as an object of ğ’®eğ“‰.
</p>

<p>
This is because a functor from a discrete category need only be a function of objects since
there are no non-identity morphisms. That is, a functor \(f : S âŸ¶ ğ’®â„¯ğ“‰\)
is determined by giving a set \(f\,s\) for each element \(s âˆˆ S\) &#x2014;since there are no non-identity morphisms.
Indeed a functor \(f : S âŸ¶ Set\) yields an <i>S</i>-targeted
function
\[ (Î£ s âˆ¶ S \,â€¢\, f\, s) â†’ S  \quad:\quad Î» (s , fs) â†’ s \]
Conversely a function \(g : X â†’ S\) yields a functor by sending elements to their pre-image sets:
\[ S âŸ¶ Set \quad:\quad Î» s â†’ (Î£ x âˆ¶ X \,â€¢\, g\, x â‰¡ s)\]
</p>

<p>
Because of this example, <code>ğ’ / B</code> can be thought of as â€˜ğ’-objects indexed by Bâ€™
&#x2013;extending this idea further leads to <i>fibred categories</i>.
</p>
</div>
</div>

<div id="outline-container-org659e4bb" class="outline-4">
<h4 id="Natural-transformations-as-functor-categories">Natural transformations as functor categories</h4>
<div class="outline-text-4" id="text-Natural-transformations-as-functor-categories">
<p>
In a similar spirit, we can identify natural transformations as functors!
\[\Func \, ğ’ \, (ğ’Ÿ ^ ğŸš) \quadâ‰…\quad (Î£ F , G âˆ¶ ğ’ âŸ¶ ğ’Ÿ \;â€¢\; \mathsf{NatTrans}\, F\, G)\]
</p>

<p>
A functor \(N : ğ’ âŸ¶ ğ’Ÿ ^ ğŸš\) gives, for each object \(C : \Obj ğ’\) an object in \(ğ’Ÿ ^ ğŸš\) which
is precisely an arrow in \(ğ’Ÿ\), rewrite it as \(N_C : F\,C âŸ¶ G\,C\) where \(F\,C \,â‰”\, N\, C\, 0\)
and \(G\, C \,â‰”\, N\, C\, 1\).
</p>

<p>
Likewise, for each arrow \(f : A âŸ¶ B\) in ğ’ we obtain an arrow \(N\, f \,:\, N\, A âŸ¶ N\, B\)
in \(ğ’Ÿ ^ ğŸš\) which is precisely a commutative square in ğ’Ÿ;
that is, a pair of ğ’Ÿ-arrows \((F\,f , G\,f) â‰” N\,f\)
with \(N_A â¨¾ G\,f \;=\; F\,f â¨¾ N_B\).
</p>

<p>
Notice that we have implicitly defined two functors \(F, G : ğ’ âŸ¶ ğ’Ÿ\).
Their object and morphism mappings are clear, but what about functoriality?
We prove it for both \(F, G\) together.
</p>

<p>
<span class="underline">Identity:</span>
</p>
\begin{calc}
     (F \,\Id \, , \, G\, \Id)
\step{ definition of $F$ and $G$ }
     N \, \Id
\step{ $N$ is a functor }
     \Id \,âˆ¶\, ğ’Ÿ ^ ğŸš
\step{ identity in arrow categories }
     (\Id , \Id)
\end{calc}

<p>
<span class="underline">Composition:</span>
</p>
\begin{calc}
     ( F (f â¨¾ g) , G (f â¨¾ g) )
   \step{ definition of $F$ and $G$ }
     N\, (f â¨¾ g)
   \step{ $N$ is a functor }
     N\, f  â¨¾  N\, g
   \step{ definition of $F$ and $G$ }
     (F\, f, G\, f) â¨¾ (F\,g , G\,g)
   \step{ composition in arrow categories }
     (F\,f â¨¾ F\,g , G\,f â¨¾ G\,g)
\end{calc}

<p>
Sweet!
</p>

<p>
Conversely, given a natural transformation \(Î· : F \overset{.}{âŸ¶} G\)
we define a functor \(N : ğ’ âŸ¶ ğ’Ÿ ^ ğŸš\) by sending objects \(C\) to \(Î·_C : F\, C âŸ¶ G\, C\),
which is an object is \(ğ’Ÿ ^ ğŸš\), and sending morphisms \(f : A âŸ¶ B\) to pairs \((G f , F f)\),
which is a morphism in \(ğ’Ÿ ^ ğŸš\) due to naturality of Î·; namely
\(Î·_A â¨¾ G\, f \;=\; F\, f â¨¾ Î·_B\).
It remains to show that \(N\) preserves identities and composition &#x2013;Exercise!
</p>

<p>
Now it remains to show that these two processes are inverses
and the isomorphism claim is complete. Woah!
</p>

<p>
Similarly, to show
\[ \Func\, (ğŸš âŠ— ğ’) \, ğ’Ÿ \qquadâ‰…\qquad (Î£ Fâ‚€ , Fâ‚ âˆ¶ ğ’ âŸ¶ ğ’Ÿ â€¢ \mathsf{NatTrans}\, Fâ‚ \, Fâ‚‚)\]
</p>

<p>
By setting \(H\, i \;=\; Fáµ¢\) on objects and likewise for morphisms
but with \(H(\Id, 1) \;=\; Î·\) where \(1 : 0 âŸ¶ 1\) is the non-identity arrow of <code>ğŸš</code>.
</p>

<p>
(Spoilers! Alternatively: <code>Arr (Func ğ’ ğ’Ÿ) â‰… ğŸš âŸ¶ ğ’ ^ ğ’Ÿ â‰… ğ’ Ã— ğŸš âŸ¶ ğ’Ÿ</code> since <code>ğ’ğ’¶ğ“‰</code> has exponentials,
   and so the objects are isomorphic; i.e., natural transformations correspond to functors <code>ğ’Ã—ğŸšâŸ¶ğ’Ÿ</code>)
</p>

<p>
Why are we mentioning this alternative statement? Trivia knowledge of-course!
</p>

<p>
On a less relevant note, if youâ€™re familiar with the theory of stretching-without-tearing,
formally known as topology which is pretty awesome, then you mightâ€™ve heard of paths and
deformations of paths are known as homotopies which are just continuous functions
\(H : X Ã— I âŸ¶ Y\) for topological spaces $X, Y,$ and \(I \,=\, [0,1]\) being the unit interval in â„.
Letting \(ğ’¥ = ğŸš\) be the â€˜categorical intervalâ€™ we have that functors \(ğ’ Ã— ğ’¥ âŸ¶ ğ’Ÿ\)
are, by the trivia-relevant result, the same as natural transformations.
That is, <i>natural transformations extend the notion of homotopies, or path-deformations.</i>
</p>

<p>
On <a href="http://mathoverflow.net/a/75686/42716">mathoverflow</a>, the above is recast succinctly as:
   A natural transformation from \(F\) to \(G\) is a functor,
   targeting an arrow category, whose â€˜sourceâ€™
   is \(F\) and whose â€˜targetâ€™ is \(G\).
   \[
       \hspace{-2em} F \overset{.}{âŸ¶} G : ğ’ âŸ¶ ğ’Ÿ \quadâ‰…\quad
       Î£ Î· âˆ¶ ğ’ âŸ¶ \mathsf{Arr}\, ğ’Ÿ â€¢\; \mathsf{Src} âˆ˜ Î· = F \;\;âˆ§\;\; \mathsf{Tgt} âˆ˜ Î· = G
   \]
   Where, the projection functors
</p>
\begin{align*}
   \mathsf{Src}&                              &:& \mathsf{Arr}\, ğ’Ÿ âŸ¶ ğ’Ÿ
\\ \mathsf{Src}& (Aâ‚ , Aâ‚‚ , f)                &=& Aâ‚
\\ \mathsf{Src}& (f  , g  , hâ‚ , hâ‚‚ , proofs) &=& hâ‚
\end{align*}
<p>
with \(\mathsf{Tgt}\) returning the other indexed items.
</p>
</div>
</div>
</div>

<div id="outline-container-org4816151" class="outline-3">
<h3 id="Graphs-as-functors">Graphs as functors</h3>
<div class="outline-text-3" id="text-Graphs-as-functors">
<p>
We give an example of a functor by building on our existing graphs setup.
After showing that graphs correspond to certain functors, we then
mention that the notion of graph-map is nothing more than the associated
natural transformations!
</p>

<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #859900; font-weight: bold;">module</span> graphs<span style="color: #268bd2;">-</span>as<span style="color: #268bd2;">-</span>functors <span style="color: #859900; font-weight: bold;">where</span>
</pre>
</div>

<p>
Let us construct our formal graph category, which contains the ingredients for
a graph and a category and nothing more than the equations needed of a category.
The main ingredients of a two-sorted graph are two sort-symbols <code>E, V</code>, along with
two function-symbols <code>s, t</code> from <code>E</code> to <code>V</code> &#x2014;this is also called â€˜the signature
of graphsâ€™. To make this into a category, we need function-symbols <code>id</code> and a composition
for which it is a unit.
</p>
<div class="org-src-container">
<pre class="src src-haskell">  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">formal objects</span>
  <span style="color: #859900; font-weight: bold;">data</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span> <span style="color: #b58900; font-style: italic;">E</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">formal arrows</span>
  <span style="color: #859900; font-weight: bold;">data</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
     s t <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; <span style="color: #b58900; font-style: italic;">E</span> <span style="color: #b58900; font-style: italic;">V</span>
     id  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {o} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; o o

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">(forward) composition</span>
  fcmp <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {a b c} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; a b <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; b c <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; a c
  fcmp f id <span style="color: #268bd2;">=</span> f
  fcmp id f <span style="color: #268bd2;">=</span> f
</pre>
</div>

<p>
Putting it all together,
</p>
<div class="org-src-container">
<pre class="src src-haskell">  <span style="color: #859900; font-weight: bold;">instance</span>
   <span style="color: #b58900; font-style: italic;">&#119970;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span>
   <span style="color: #b58900; font-style: italic;">&#119970;</span> <span style="color: #268bd2;">=</span> record
        { <span style="color: #b58900; font-style: italic;">Obj</span>     <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;
        ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span>     <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321;
        ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>     <span style="color: #268bd2;">=</span> fcmp
        ; assoc   <span style="color: #268bd2;">=</span> &#955; {a b c d f g h} <span style="color: #268bd2;">&#8594;</span> fcmp<span style="color: #268bd2;">-</span>assoc f g h
        ; <span style="color: #b58900; font-style: italic;">Id</span>      <span style="color: #268bd2;">=</span> id
        ; leftId  <span style="color: #268bd2;">=</span> left<span style="color: #268bd2;">-</span>id
        ; rightId <span style="color: #268bd2;">=</span> right<span style="color: #268bd2;">-</span>id
        }
    <span style="color: #859900; font-weight: bold;">where</span>
       <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">exercises: prove associativity, left and right unit laws</span>
</pre>
</div>

<p>
Now we can show that every graph <code>G</code> gives rise to a functor: A semantics of <code>ğ’¢</code> in <code>ğ’®eğ“‰</code>.
</p>
<div class="org-src-container">
<pre class="src src-haskell">  toFunc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119970;</span> <span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span>
  toFunc <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">=</span> record
    { obj  <span style="color: #268bd2;">=</span> &#10214;<span style="color: #859900; font-weight: bold;">_</span>&#10215;&#8320;
    ; mor  <span style="color: #268bd2;">=</span> &#10214;<span style="color: #859900; font-weight: bold;">_</span>&#10215;&#8321;
    ; id   <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
    ; comp <span style="color: #268bd2;">=</span> &#955; {x y z f g} <span style="color: #268bd2;">&#8594;</span> fcmp<span style="color: #268bd2;">-&#10814;</span> {x} {y} {z} {f} {g}
    }
    <span style="color: #859900; font-weight: bold;">where</span>
      &#10214;<span style="color: #859900; font-weight: bold;">_</span>&#10215;&#8320; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119970;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span>
      &#10214; <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">V</span> &#10215;&#8320; <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span>
      &#10214; <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">E</span> &#10215;&#8320; <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#931;</span> x <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#8226;</span> <span style="color: #b58900; font-style: italic;">&#931;</span> y <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#8226;</span> Graph._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">G</span> x y

      &#10214;<span style="color: #859900; font-weight: bold;">_</span>&#10215;&#8321; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#10230;</span> y <span style="color: #268bd2;">&#8594;</span> (&#10214; x &#10215;&#8320; <span style="color: #268bd2;">&#8594;</span> &#10214; y &#10215;&#8320;)
      &#10214; s &#10215;&#8321; (src , tgt , edg) <span style="color: #268bd2;">=</span> src
      &#10214; t &#10215;&#8321; (src , tgt , edg) <span style="color: #268bd2;">=</span> tgt
      &#10214; id &#10215;&#8321; x <span style="color: #268bd2;">=</span> x

      <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Exercise: fcmp is realised as functional composition</span>
      fcmp<span style="color: #268bd2;">-&#10814;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y z} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; x y} {g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; y z} <span style="color: #268bd2;">&#8594;</span> &#10214; fcmp f g &#10215;&#8321; <span style="color: #268bd2;">&#8801;</span> &#10214; f &#10215;&#8321; <span style="color: #268bd2;">&#10814;</span> &#10214; g &#10215;&#8321;
</pre>
</div>
<p>
Conversely, every such functor gives a graph whose vertices and edges are the sets
associated with the sort-symbols <code>V</code> and <code>E</code>, respectively.
</p>
<div class="org-src-container">
<pre class="src src-haskell">  fromFunc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119970;</span> <span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Graph</span>
  fromFunc <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">=</span> record {
      <span style="color: #b58900; font-style: italic;">V</span>      <span style="color: #268bd2;">=</span> obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">V</span>
    ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span>    <span style="color: #268bd2;">=</span> &#955; x y <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#931;</span> e <span style="color: #268bd2;">&#8758;</span> obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">&#8226;</span> src e <span style="color: #268bd2;">&#8801;</span> x <span style="color: #268bd2;">&#215;</span> tgt e <span style="color: #268bd2;">&#8801;</span> y
             <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">the type of edges whose source is x and target is y</span>
    }
    <span style="color: #859900; font-weight: bold;">where</span> tgt src <span style="color: #b58900; font-style: italic;">:</span> obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">&#8594;</span> obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">V</span>
          src <span style="color: #268bd2;">=</span> mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321;<span style="color: #268bd2;">.</span>s
          tgt <span style="color: #268bd2;">=</span> mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321;<span style="color: #268bd2;">.</span>t
</pre>
</div>

<p>
It is to be noted that we can define â€˜â€˜graphs over ğ’â€™â€™ to be the category <code>Func ğ’¢ ğ’</code>.
Some consequences are as follows: Notion of graph in any category, the notion of graph-map
is the specialisation of natural transformation (!), and most importantly, all the power of functor categories
is avaiable for the study of graphs.
</p>

<p>
In some circles, you may hear people saying an â€˜algebra over the signature of graphsâ€™ is an interpretation
domain (<code>ğ’</code>) and an operation (<code>Functor ğ’¢ ğ’</code>) interpreting the symbols. <i>Nice!</i>
</p>
</div>
</div>
</div>
<div id="outline-container-orgfb16ac7" class="outline-2">
<h2 id="A-few-categorical-constructions">A few categorical constructions</h2>
<div class="outline-text-2" id="text-A-few-categorical-constructions">
<p>
We briefly take a pause to look at the theory of category theory.
In particular, we show a pair of constructions to get new categories from old ones,
interpret these constructions from the view of previously mentioned categories, and
discuss how to define the morphism type <code>_âŸ¶_</code> on morphisms themselves, thereby
yielding a functor.
</p>
</div>

<div id="outline-container-orgf300093" class="outline-3">
<h3 id="Opposite">Opposite</h3>
<div class="outline-text-3" id="text-Opposite">
<p>
The â€˜dualâ€™ or â€˜oppositeâ€™ category ğ’áµ’áµ– is the category constructed from ğ’ by
reversing arrows: \((A âŸ¶_{ğ’áµ’áµ–} B) \;â‰”\; (B âŸ¶_ğ’ A)\), then necessarily
\((f â¨¾_{ğ’áµ’áµ–} g) \;â‰”\; g â¨¾_ğ’ f\).
A â€˜contravariant functorâ€™, or â€˜cofunctorâ€™, is a functor F from an opposite category and so
there is a reversal of compositions: \(F(f \,â¨¾\, g) \;=\; F g \,â¨¾\, F f\).
</p>
<pre class="example">
 _áµ’áµ– : âˆ€ {i j} â†’ Category {i} {j} â†’ Category
 ğ’ áµ’áµ– = {! exercise !}
</pre>
<p>
Notice that \((ğ’ áµ’áµ–) áµ’áµ– \;=\; ğ’\) and \(ğ’ áµ’áµ– \;â‰…\; ğ’\)
&#x2013;one may have an intuitive idea of what this isomorphsim means,
but formally it is only meaningful in the context of an ambient category; keep reading ;)
</p>

<p>
We must admit that for categories, the notion of isomorphism is considered less useful
than that of equivalence which weakens the condition of the to-from functors being
inverses to just being naturally isomorphic to identities; C.f., â€˜evilâ€™ above.
</p>

<p>
Some interpretations:
</p>

<ul class="org-ul">
<li><p>
ğ’®eğ“‰áµ’áµ– is usual sets and functions but with â€˜backwards compositionâ€™:
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #859900; font-weight: bold;">infix</span> 10 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8728;</span><span style="color: #859900; font-weight: bold;">_</span>
 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8728;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j } &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}&#10628; {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#8594;</span>  <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">C</span>
 f <span style="color: #268bd2;">&#8728;</span> g <span style="color: #268bd2;">=</span> g <span style="color: #268bd2;">&#10814;</span> f
</pre>
</div>
<p>
Indeed, we have <code>g â¨¾ f within ğ’  =  f âˆ˜ g within ğ’ áµ’áµ–</code>; which is how these composition operators
 are usually related in informal mathematics (without mention of the ambient categories of course).
</p>

<p>
On a more serious note, the opposite of ğ’®eğ“‰ is clearly ğ“‰â„¯ğ’® haha
&#x2014;technically for the purposes of this pun we identify the words â€˜oppositeâ€™ and â€˜reverseâ€™.
</p></li>

<li>For a discrete category, its opposite is itself.</li>

<li>For a monoid (viewed as a category), its opposite is itself if the monoid operation is commutative, otherwise
it is the â€˜dual monoidâ€™.</li>

<li><p>
For a poset (viewed as a category), its opposite is the â€˜dual posetâ€™: \((P, âŠ‘)áµ’áµ– \;=\; (P, âŠ’)\).
</p>

<p>
In particular, the â€˜least upper boundâ€™, or â€˜supremumâ€™ in \((P, âŠ‘)\) of two elements
\(x,y\) is an element \(s\) with the â€˜universal propertyâ€™: \(âˆ€ z â€¢\; x âŠ‘ z âˆ§ y âŠ‘ z \;â‰¡\; s âŠ‘ z\).
However, switching âŠ‘ with âŠ’ gives us the notion of â€˜infimumâ€™, â€˜greatest upper boundâ€™!
So any theorems about supremums automatically hold for infimums since the infifum is nothing
more than the supremum in the dual category of the poset.
</p>

<p>
It is not difficult to see that this idea of â€œ2 for the price of 1â€ for theorems holds for all
categories.
</p></li>

<li><b>Stone Duality:</b>
<code>FinBoolAlg â‰ƒ FinSets áµ’áµ–</code> , witnessed by considering the collection of
atoms of a Boolean Algebra in one direction and the power set in the other.
Finiteness can be removed at the cost of completeness and atomicitiy,
<code>CompleteAtomicBoolAlg â‰ƒ ğ’®â„¯ğ“‰ áµ’áµ–</code>.</li>

<li>What about the category of functors and natural transformations?</li>
</ul>

<p>
Speaking of functors, we can change the type of a functor by <code>áµ’áµ–</code>-ing its source and target,
while leaving it alone,
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">this only changes type</span>
 opify <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j i&#8217; j&#8217;} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}} {<span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i&#8217;} {j&#8217;}}
      <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> &#7506;&#7510;) (<span style="color: #b58900; font-style: italic;">&#119967;</span> &#7506;&#7510;)
 opify <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">=</span> record { obj   <span style="color: #268bd2;">=</span>  obj <span style="color: #b58900; font-style: italic;">F</span>
                  ; mor   <span style="color: #268bd2;">=</span>  mor <span style="color: #b58900; font-style: italic;">F</span>
                  ; id    <span style="color: #268bd2;">=</span>  Functor.id <span style="color: #b58900; font-style: italic;">F</span>
                  ; comp  <span style="color: #268bd2;">=</span>  Functor.comp <span style="color: #b58900; font-style: italic;">F</span>
                  }
</pre>
</div>

<blockquote>
<p>
Category Theory is the â€˜opâ€™ium of the people!
</p>

<p>
&#x2014; Karl Marx might say it had cats existed in his time
</p>
</blockquote>

<p>
This two definitions seem to indicate that we have some form of opposite-functor â€¦ ;)
&#x2014;keep reading!
</p>

<p>
<code>opify</code> seems to show that <code>Functor ğ’ ğ’Ÿ â‰¡ Functor (ğ’ áµ’áµ–) (ğ’Ÿ áµ’áµ–)</code>, or alternatively a
functor can have â€˜two different typesâ€™ &#x2014;this is akin to using the integers as reals
without writing out the inclusion formally, leaving it implicit; however, in the Agda mechanization
everything must be made explicit &#x2014;the type system doesnâ€™t let you get away with such things.
Professor Maarten Fokkinga has informed me that
the formalization allowing multiple-types is called a
<a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">pre-category</a>.
</p>
</div>

<div id="outline-container-org407e1b8" class="outline-4">
<h4 id="ah-yeah-and-dagger-categories">ah-yeah: âˆ‚ and dagger categories</h4>
<div class="outline-text-4" id="text-ah-yeah-and-dagger-categories">
<p>
With <code>ğ’ğ’¶ğ“‰</code> in-hand, we can formalise the opposite, or âˆ‚ual, functor:
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #268bd2;">&#8706;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span> {i} {j}) <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span>
 <span style="color: #268bd2;">&#8706;</span> <span style="color: #268bd2;">=</span> record { obj <span style="color: #268bd2;">=</span> _&#7506;&#7510; ; mor <span style="color: #268bd2;">=</span> opify ; id <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl ; comp <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl }
</pre>
</div>

<p>
Conjecture: Assuming categories are equipped with a contravariant involutionary functor
that is identity on objects, we can show that the identity functor is naturally isomorphic
to the opposite functor.
</p>

<div class="org-src-container">
<pre class="src src-haskell"> ah<span style="color: #268bd2;">-</span>yeah <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j} (<span style="color: #859900; font-weight: bold;">let</span> <span style="color: #b58900; font-style: italic;">Cat</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Obj</span> (<span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span> {i} {j}))
     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">identity on objects cofunctor, sometimes denoted _&#728;</span>
     <span style="color: #268bd2;">&#8594;</span> (dual <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Cat</span>) {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>}  <span style="color: #268bd2;">&#8594;</span>  x <span style="color: #268bd2;">&#10230;</span> y <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>  <span style="color: #268bd2;">&#8594;</span>  y <span style="color: #268bd2;">&#10230;</span> x <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>)
     <span style="color: #268bd2;">&#8594;</span> (<span style="color: #b58900; font-style: italic;">Id</span><span style="color: #268bd2;">&#728;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Cat</span> &#10628; {x <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">&#8594;</span> dual <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">Id</span>  <span style="color: #268bd2;">&#8801;</span>  <span style="color: #b58900; font-style: italic;">Id</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">=</span> x})
     <span style="color: #268bd2;">&#8594;</span> (<span style="color: #268bd2;">&#10814;-&#728;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Cat</span> &#10628; {x y z <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {f <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y} {g <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#10230;</span> z}
            <span style="color: #268bd2;">&#8594;</span> dual <span style="color: #b58900; font-style: italic;">&#119966;</span> (f <span style="color: #268bd2;">&#10814;</span> g <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>)  <span style="color: #268bd2;">&#8801;</span>  (dual <span style="color: #b58900; font-style: italic;">&#119966;</span> g) <span style="color: #268bd2;">&#10814;</span> (dual <span style="color: #b58900; font-style: italic;">&#119966;</span> f) <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>)
     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">which is involutionary</span>
     <span style="color: #268bd2;">&#8594;</span> (<span style="color: #268bd2;">&#728;&#728;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Cat</span> &#10628; {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {f <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y} <span style="color: #268bd2;">&#8594;</span> dual <span style="color: #b58900; font-style: italic;">&#119966;</span> (dual <span style="color: #b58900; font-style: italic;">&#119966;</span> f) <span style="color: #268bd2;">&#8801;</span> f)
     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">which is respected by other functors</span>
     <span style="color: #268bd2;">&#8594;</span> (respect <span style="color: #b58900; font-style: italic;">:</span> &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Cat</span> &#10628; {<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>} {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {f <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y}
                <span style="color: #268bd2;">&#8594;</span> mor <span style="color: #b58900; font-style: italic;">F</span> (dual <span style="color: #b58900; font-style: italic;">&#119966;</span> f) <span style="color: #268bd2;">&#8801;</span> dual <span style="color: #b58900; font-style: italic;">&#119967;</span> (mor <span style="color: #b58900; font-style: italic;">F</span> f))
     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">then</span>
     <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8706;</span> <span style="color: #268bd2;">&#8773;</span> <span style="color: #b58900; font-style: italic;">Id</span> within <span style="color: #b58900; font-style: italic;">Func</span> (<span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span> {i} {j}) <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span>
</pre>
</div>
<pre class="example">
 ah-yeah = {! exercise !}
</pre>
<p>
Some things to note.
</p>

<ul class="org-ul">
<li><p>
Categories whose morphisms are all isomorphisms are called â€˜groupoidsâ€™ &#x2014;groups are just one-object groupoids.
Consequently, restricted to groupoids the opposite functor is naturally isomorphic to the identity functor!
</p>

<p>
In fact, the group case was the motivator for me to conjecture the theorem, which took a while to prove since I hadnâ€™t
a clue what I needed to assume. Here weâ€™d use <code>a Ë˜ â‰” a â»Â¹</code>.
</p></li>

<li><p>
Consider the category <code>Rel</code> whose objects are sets and whose morphisms are â€˜typed-relationsâ€™ \((S, R, T)\),
where \(R\) is a relation from set \(S\) to set \(T\), and
composition is just relational composition
&#x2014;the notion of â€˜untypedâ€™, or multi-typed, morphisms is formalized as pre-categories;
see <a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">Fokkinga</a>.
Then we can define an endofunctor by taking <code>-Ë˜</code> to be relational converse: \(x \,(R Ë˜)\, y \;â‰¡\; y \,R\, x\).
Consequently, restricted to the category <code>Rel</code> we have that the opposite functor is naturally isomorphic to the identity functor.
</p></li>
</ul>

<p>
The above items are instance of a more general concept, of course.
</p>

<p>
A category with an involutionary contravariant endofunctor that is the identity on objects
is known as <i>a dagger category, an involutive/star category, or a category with converse</i>
&#x2014;and the functor is denoted as a superscript suffix by <code>â€ , *, Ë˜</code>, respectively.
The dagger notation probably comes from
the Hilbert space setting while the converse notation comes from the relation algebra setting.
As far as I know, the first two names are more widely known.
A dagger category bridges the gap between arbitrary categories and groupoids.
</p>

<p>
Just as matrices with matrix multiplication do not form a monoid but rather a category, we have
that not all matrices are invertible but they all admit transposition and so we have a dagger
category. In the same vein, relations admit converse and so give rise to a category with converse.
</p>

<p>
Besides relations and groupoids, other examples include:
</p>
<ul class="org-ul">
<li>discrete categories with the dagger being the identity functor</li>
<li>every monoid with an anti-involution is trivially a dagger category; e.g.,
lists with involution being reverse.</li>
<li>commutative monoids are anti-involutive monoids with anti-involution being identity</li>
</ul>

<p>
Spoilers!! Just as the category of categories is carestian closed, so too is the category of dagger
categories and dagger preserving functors &#x2013;c.f.,the <code>respect</code> premise above.
</p>
</div>
</div>
</div>

<div id="outline-container-org22d4684" class="outline-3">
<h3 id="Products">Products</h3>
<div class="outline-text-3" id="text-Products">
<p>
For any two categories ğ’ and ğ’Ÿ we can construct their â€˜productâ€™ category
\(ğ’ âŠ— ğ’Ÿ\) whose objects and morphisms are pairs with components from ğ’ and ğ’Ÿ:
\(\Obj\, (ğ’ âŠ— ğ’Ÿ) \;\;=\;\; \Obj\, ğ’ \,Ã—\, \Obj\, ğ’Ÿ\) and
\((A , X) âŸ¶_{ğ’ âŠ— ğ’Ÿ} (B , Y) \;\;=\;\; (A âŸ¶_ğ’ B) \,Ã—\, (X âŸ¶_ğ’Ÿ Y)\).
</p>
<pre class="example">
 -- we cannot overload symbols in Agda and so using â€˜âŠ—â€™ in-place of more common â€˜Ã—â€™.
 _âŠ—_ : âˆ€ {i j iâ€™ jâ€™} â†’ Category {i} {j} â†’ Category {iâ€™} {jâ€™} â†’ Category
 ğ’ âŠ— ğ’Ÿ = {! exercise !}
</pre>
<p>
Observe that in weaker languages, a category is specified by its objects, morphisms, and composition
&#x2014;the proof obligations are delegated to comments, if they are realized at all.
In such settings, one would need to prove that this construction actually produces a full-fledged
category. Even worse, this proof may be a distance away in some documentation.
With dependent types, our proof obligation is nothing more than another component of the program,
a piece of the category type.
</p>

<p>
In a similar fashion we can show that the sum of two categories is again a category and in general
we have the same for quantified variants: <code>Î  ğ’ âˆ¶ Family â€¢ ğ’</code>, likewise for â€˜Î£â€™.
For the empty family, the empty sum yields the category <code>ğŸ˜</code> with no objects and
the empty product yields the category <code>ğŸ™</code> of one object.
One can then show the usual â€˜laws of arithmeticâ€™ &#x2014;i.e., Ã—,+ form a commutative monoid, up to isomorphism&#x2014;
hold in this setting: Letting <code>â˜… âˆˆ {+,Ã—}</code>, we have
associtivity <code>A â˜… (B â˜… C) â‰… (A â˜… B) â˜… C</code>, symmetry <code>A â˜… B â‰… B â˜… A</code>,
unit <code>ğŸ™ Ã— A â‰… ğŸ˜ + A â‰… A</code>, and zero <code>ğŸ˜ Ã— A â‰… ğŸ˜</code>.
These notions can be defined for any category though the objects may or may not exist
&#x2014; in <code>ğ’®eğ“‰</code> and <code>ğ’¢ğ“‡ğ’¶ğ“…ğ’½</code>, for example, they do exist ;) &#x2014;and these associated arithmetical
laws also hold.
</p>

<p>
<i>Question!</i> What of the distributivity law,
<code>A Ã— (B + C) â‰… (A Ã— B) + (A Ã— C)</code>, does it hold in the mentioned cases?
Let <code>ğ’«ğ’®eğ“‰</code> be the category of sets with a distinguished point, i.e.,  <code>Î£ S : Obj ğ’®eğ“‰ â€¢ S</code>, and
functions that preserve the â€˜pointâ€™, one can then show &#x2014;if he or she so desires, and is not
lazy&#x2014; that this category has notions of product and sum but distributivity fails.
</p>

<p>
Some interpretations:
</p>
<ul class="org-ul">
<li>For discrete categories, this is the usual Cartesian product.</li>
<li>For monoid (or poset) categories, this says that the product of two monoids (or posets) is again
a monoid (respectively poset. This follows since the product does not affect the number of
objects and so the product is again a one-object category, i.e., a monoid (poset respectively).</li>
<li>Interestingly, the <i>sum</i> of two monoids is <b>not</b> formed by their disjoint union: Instead
it is the set of all alternating lists of elements from the two given monoids.
Exercise: Find the associated operation ;-)</li>
</ul>

<p>
As expected, we have projections,
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #b58900; font-style: italic;">Fst</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j i&#8217; j&#8217;} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}} {<span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i&#8217;} {j&#8217;}}
     <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) <span style="color: #b58900; font-style: italic;">&#119966;</span>
 <span style="color: #b58900; font-style: italic;">Fst</span> <span style="color: #268bd2;">=</span> record { obj <span style="color: #268bd2;">=</span> proj&#8321; ; mor <span style="color: #268bd2;">=</span> proj&#8321; ; id <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl ; comp <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl }

 <span style="color: #b58900; font-style: italic;">Snd</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j i&#8217; j&#8217;} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}} {<span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i&#8217;} {j&#8217;}}
     <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) <span style="color: #b58900; font-style: italic;">&#119967;</span>
 <span style="color: #b58900; font-style: italic;">Snd</span> <span style="color: #268bd2;">=</span> record { obj <span style="color: #268bd2;">=</span> proj&#8322; ; mor <span style="color: #268bd2;">=</span> proj&#8322; ; id <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl ; comp <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl }
</pre>
</div>
</div>

<div id="outline-container-orgae174fe" class="outline-4">
<h4 id="Currying">Currying</h4>
<div class="outline-text-4" id="text-Currying">
<p>
For types we have \[ (ğ’³ Ã— ğ’´ âŸ¶ ğ’µ) \quadâ‰…\quad (ğ’³ âŸ¶ ğ’µ ^ ğ’´) \quadâ‰…\quad (ğ’´ âŸ¶ ğ’µ ^ ğ’³)\]
Since categories are essentially types endowed with nifty structure,
we expect it to hold in that context as well.
</p>
<pre class="example">
  -- Everyone usually proves currying in the first argument,
  -- letâ€™s rebel and do so for the second argument
 curryâ‚‚ : âˆ€ {ix jx iy jy iz jz}
          {ğ’³ : Category {ix} {jx}} {ğ’´ : Category {iy} {jy}} {ğ’µ : Category {iz} {jz}}
        â†’ Functor (ğ’³ âŠ— ğ’´) ğ’µ â†’ Functor ğ’´ (Func ğ’³ ğ’µ)
 curryâ‚‚ = {! exercise !}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgff554b0" class="outline-3">
<h3 id="Pointwise-extensions-and-the-hom-functor">Pointwise extensions and the hom functor</h3>
<div class="outline-text-3" id="text-Pointwise-extensions-and-the-hom-functor">
<p>
Just as addition can be extended to number-valued functions pointwise, \(f + g \;â‰”\; Î» x â†’ f x + g x\),
we can do the same thing with functors.
</p>
<pre class="example">
 -- For bifunctor â€˜âŠ•â€™ and functors â€˜F, Gâ€™, we have a functor â€˜Î» x â†’ F x âŠ• G xâ€™
 pointwise : âˆ€ {ic jc id jd ix jx iy jy}
   {ğ’ : Category {ic} {jc}} {ğ’Ÿ : Category {id} {jd}} {ğ’³ : Category {ix} {jx}} {ğ’´ : Category {iy} {jy}}
   â†’ Functor (ğ’³ âŠ— ğ’´) ğ’Ÿ â†’ Functor ğ’ ğ’³ â†’ Functor ğ’ ğ’´
   â†’ Functor ğ’ ğ’Ÿ
 pointwise = {! exercise !}
</pre>
<p>
By â€˜extensionalityâ€™ <code>p â‰¡ (projâ‚ p , projâ‚‚ p)</code>, we have that the pointwise extension along the projections
is the orginal operation.
</p>
<div class="org-src-container">
<pre class="src src-haskell"> exempli<span style="color: #268bd2;">-</span>gratia <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">&#119987;</span> <span style="color: #b58900; font-style: italic;">&#119988;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {&#8467;&#8320;} {&#8467;&#8320;}} (<span style="color: #268bd2;">&#8853;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119987;</span> <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119988;</span>) <span style="color: #b58900; font-style: italic;">&#119967;</span>)
                <span style="color: #268bd2;">&#8594;</span> <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #859900; font-weight: bold;">_</span>&#10216;<span style="color: #268bd2;">&#8853;</span>&#10217;<span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> pointwise <span style="color: #268bd2;">&#8853;</span>
                   <span style="color: #859900; font-weight: bold;">in</span>
                      <span style="color: #b58900; font-style: italic;">Fst</span> &#10216;<span style="color: #268bd2;">&#8853;</span>&#10217; <span style="color: #b58900; font-style: italic;">Snd</span> <span style="color: #268bd2;">&#8801;</span> <span style="color: #268bd2;">&#8853;</span>
 exempli<span style="color: #268bd2;">-</span>gratia <span style="color: #b58900; font-style: italic;">Bi</span> <span style="color: #268bd2;">=</span> funcext (<span style="color: #268bd2;">&#8801;-</span>cong (obj <span style="color: #b58900; font-style: italic;">Bi</span>) <span style="color: #268bd2;">&#8801;-</span>refl) (<span style="color: #268bd2;">&#8801;-</span>cong (mor <span style="color: #b58900; font-style: italic;">Bi</span>) <span style="color: #268bd2;">&#8801;-</span>refl)
</pre>
</div>

<p>
An example bifunctor is obtained by extending the â€˜âŸ¶â€™ to morphisms:
Given <code>f : A âŸ¶ B , g : C âŸ¶ D</code> we define <code>(f âŸ¶ g) : (B âŸ¶ C) â†’ (A âŸ¶ C)</code> by
<code>Î» h â†’ f â¨¾ h â¨¾ g</code> as this is the only way to define it so as to meet the type requirements.
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #b58900; font-style: italic;">Hom</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j} } <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> &#7506;&#7510; <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>) (<span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span> {j})
   <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">hence contravariant in &#8216;first arg&#8217; and covaraint in &#8216;second arg&#8217;</span>
 <span style="color: #b58900; font-style: italic;">Hom</span> {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">=</span>
   <span style="color: #859900; font-weight: bold;">let</span>
     <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
     <span style="color: #859900; font-weight: bold;">instance</span> <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
     <span style="color: #268bd2;">&#10814;-</span>cong&#8322; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span>} {g g&#8217; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10230;</span> <span style="color: #b58900; font-style: italic;">C</span>}
             <span style="color: #268bd2;">&#8594;</span> g <span style="color: #268bd2;">&#8801;</span> g&#8217; <span style="color: #268bd2;">&#8594;</span> f <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g <span style="color: #268bd2;">&#8801;</span> f <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g&#8217;
     <span style="color: #268bd2;">&#10814;-</span>cong&#8322;  q  <span style="color: #268bd2;">=</span>  <span style="color: #268bd2;">&#8801;-</span>cong&#8322; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">&#8801;-</span>refl q
   <span style="color: #859900; font-weight: bold;">in</span> record {
     obj <span style="color: #268bd2;">=</span> &#955;{ (<span style="color: #b58900; font-style: italic;">A</span> , <span style="color: #b58900; font-style: italic;">B</span>) <span style="color: #268bd2;">&#8594;</span>  <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span> }
   ; mor <span style="color: #268bd2;">=</span> &#955;{ (f , g) <span style="color: #268bd2;">&#8594;</span> &#955; h <span style="color: #268bd2;">&#8594;</span> f <span style="color: #268bd2;">&#10814;</span> h <span style="color: #268bd2;">&#10814;</span> g }
   ; id <span style="color: #268bd2;">=</span> extensionality (&#955; {h} <span style="color: #268bd2;">&#8594;</span> begin
        <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> h <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span>
      <span style="color: #268bd2;">&#8801;</span>&#10216; leftId &#10217;
        h <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span>
      <span style="color: #268bd2;">&#8801;</span>&#10216; rightId &#10217;
        h
      <span style="color: #268bd2;">&#8718;</span>)
   ; comp <span style="color: #268bd2;">=</span>  &#955; {x y z fg fg&#8217;} <span style="color: #268bd2;">&#8594;</span>
       <span style="color: #859900; font-weight: bold;">let</span> (f , g) <span style="color: #268bd2;">=</span> fg ; (f&#8217; , g&#8217;) <span style="color: #268bd2;">=</span> fg&#8217; <span style="color: #859900; font-weight: bold;">in</span> extensionality (&#955; {h} <span style="color: #268bd2;">&#8594;</span> begin
            (f&#8217; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> f) <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> h <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> (g <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g&#8217;)
          <span style="color: #268bd2;">&#8801;</span>&#10216; assoc &#10217;
            f&#8217; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> (f <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> (h <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> (g <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g&#8217;)))
          <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #268bd2;">&#10814;-</span>cong&#8322; (<span style="color: #268bd2;">&#8801;-</span>sym assoc) &#10217;
            f&#8217; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> ((f <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> h) <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> (g <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g&#8217;))
          <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #268bd2;">&#10814;-</span>cong&#8322; (<span style="color: #268bd2;">&#8801;-</span>sym assoc) &#10217;
            f&#8217; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> ((f <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> h) <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g) <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g&#8217;
          <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #268bd2;">&#10814;-</span>cong&#8322; (<span style="color: #268bd2;">&#8801;-</span>cong&#8322; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> assoc <span style="color: #268bd2;">&#8801;-</span>refl) &#10217;
            f&#8217; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> (f <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> h <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g) <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g&#8217;
          <span style="color: #268bd2;">&#8718;</span>)
     }
</pre>
</div>
<p>
The naming probably comes from the algebra/monoid case where the functors are
monoid <code>hom</code>-omorphisms. Some prefer to use the name <code>Mor</code>, short for <code>mor</code>-phisms,
and thatâ€™s cool too. While Haskell programmers might call this the <code>Reader</code> functor.
</p>

<p>
Usual notation for this functor is <code>Hom</code>, but I like Fokkingaâ€™s much better.
He uses <code>(_âŸ¶_)</code> and writes <code>(f âŸ¶ g) = Î» h â€¢ f â¨¾ h â¨¾ g</code>
&#x2014;the first argument of Hom is the first argument of the composition and the last
argument to Hom is the last argument of the resulting composition :-)
</p>
</div>
</div>
</div>
<div id="outline-container-orgff09a24" class="outline-2">
<h2 id="ğ’®implicity-ğ’°nderlies-ğ’omplexity">ğ’®implicity ğ’°nderlies ğ’omplexity</h2>
<div class="outline-text-2" id="text-ğ’®implicity-ğ’°nderlies-ğ’omplexity">
<blockquote>
<p>
One way is to make it so ğ’®imple that there are obviously no deficiencies, and the other way is to
make it so ğ’omplicated that there are no obvious deficiencies. The first method is far more
difficult. It demands the same skill, devotion, insight, and even inspiration as the discovery of
the simple physical laws which ğ’°nderlie the complex phenomena of nature.
</p>

<p>
â”€<a href="https://en.wikiquote.org/wiki/C._A._R._Hoare">C.A.R. Hoare</a>
</p>
</blockquote>

<small>
<div class="org-center">
<p>
( The ğ’omplex philosophy behinds games such as Chess and
<a href="http://playgo.to/iwtg/en/">Go</a> arise from some ğ’®imple board game rules.
)
</p>
</div>
</small>

<p>
In this section we discuss what it means to be a â€˜forgetful functorâ€™?
&#x2013;Also called an `ğ’°nderlying functor'.
</p>

<p>
The modifier â€˜forgetfulâ€™ is meaningful when thereâ€™s a notion of extra structure.
Indeed any functor <i>F : ğ’ âŸ¶ ğ’®</i> can be thought of as forgetful by construing the objects of
ğ’ as objects of ğ’® with extra structure.
Mostly: <i>You know it (to be forgetful) when you see it!</i>
</p>
</div>

<div id="outline-container-orgeecdce6" class="outline-3">
<h3 id="Being-forgetful-from-injections-to-faithful-functors">Being forgetful: from injections to faithful functors</h3>
<div class="outline-text-3" id="text-Being-forgetful-from-injections-to-faithful-functors">
<p>
A common example from set theory is the â€˜inclusionâ€™ of a subset \(A\) of \(B\), the injection
\(Î¹ : A â†ª B : a â†¦ a\) &#x2014;it is essentially a form of â€˜type castingâ€™: \(a âˆˆ A\) and \(Î¹ a \;=\; a âˆˆ B\).
Such injections â€˜forgetâ€™ the property that the argument is actually a member of a specified
subset. Indeed, construing sets as categories then functions becomes functors and inclusions
are then forgetful functors!
</p>

<p>
Since a functor <i>F</i> consists of two maps <i>(Fâ‚€, Fâ‚) â‰” (obj F, mor F)</i> and some properties, we can speak about properties of the
functor and about properties of either of its maps.
The common definitions are a functor \(F\) is:
</p>
<dl class="org-dl">
<dt>faithful</dt><dd>If its operation on morphisms is <i>injective</i>, and it is</dd>
<dt>full    </dt><dd>If morphisms starting and ending at <i>F</i> are a result of applying \(F\);  <br>
i.e., <i>Fâ‚</i> is surjective <i>on</i> the image of <i>Fâ‚€</i>:  <br>
\(âˆ€ x,y âˆ¶ Obj \;â€¢\; âˆ€ g âˆ¶ Fâ‚€ x âŸ¶ Fâ‚€ y \;â€¢\; âˆƒ f âˆ¶ x âŸ¶ y \;â€¢\; Fâ‚ f = g\).</dd>
</dl>

<p>
Now we can generalize the previous example.
Every faithful functor <i>F : ğ’ âŸ¶ ğ’Ÿ</i> can be construed as forgetful:
The ğ’-maps can be embedded into the ğ’Ÿ-maps, since F is faithful, and so can be thought of
as a special sub-collection of the ğ’Ÿ-maps; then \(F\) â€˜forgetsâ€™ the property of being in this
special sub-collection.
</p>

<p>
Are faithful functors in abundance? Well any functor forgetting only axioms
(and/or structure) is faithful:
</p>

<ol class="org-ol">
<li>Suppose ğ’ consists of ğ’Ÿ objects satisfying some axioms and ğ’Ÿ maps preserving this structure.</li>
<li>That is, ğ’ has pairs of ğ’Ÿ objects/morphisms with a proof that it satisfies the axioms/preserves-structure.</li>
<li>Then â€œ\(F : ğ’ âŸ¶ ğ’Ÿ\) forgets only axiomsâ€ means \(F\, (f, \mathsf{proof}) \;=\; f\).</li>
<li><p>
Now given, \(F (f , prf) = F (g , prf) \;â‡”\; f = g \;â‡”\; (f , prf) = (g , prf)\)
&#x2013; equality does not (extensionally) depend on proof components.
</p>

<p>
Hence, faithful :-)
</p>

<p>
(Likewise for forgetting extra structure).
</p></li>
</ol>

<p>
Of course weâ€™re not saying all forgetful functors are necessarily faithful.
A simple counterexample is the absolute value function:
Given a real number \(x\) itâ€™s absolute value \(âˆ£xâˆ£\) is obtained by totally ignoring its sign
&#x2014;of course \(x\) and \(âˆ£xâˆ£\) are equidistant from 0, the relation equidistant-from-0 is an equivalence
relation &#x2013;Exercise!&#x2013;, and so the the two are isomorphic in some sense.
</p>

<p>
Motivated by this, given a set \(S\) itâ€™s size is denoted \(âˆ£ S âˆ£\) which totally forgets about the
elements of the set &#x2014;of course it can be shown that two sets are isomorphic precisely if they are
equinumerous.
</p>

<p>
I assume it is with these as motivators, some people write \(âˆ£Â·âˆ£\) for a forgetful functor.
</p>

<p>
( Exercise: A functor <code>F : ğ’ â‰ƒ ğ’Ÿ</code> is (part of) an equivalence iff it is full,
faithful, and â€˜â€˜essentially surjective on objectsâ€™â€™:
 <code>âˆ€ D : Obj ğ’Ÿ â€¢ Î£ C : Obj ğ’ â€¢ F C â‰… D</code> &#x2014;note the iso. )
</p>
</div>
</div>

<div id="outline-container-org32d8fd1" class="outline-3">
<h3 id="Of-basis-vectors">Of basis vectors</h3>
<div class="outline-text-3" id="text-Of-basis-vectors">
<p>
If youâ€™ve ever studied abstract algebra &#x2014;the math with vector spaces&#x2014; then you may recall that
a collection of vectors â„¬ is called a â€˜basisâ€™ if every vector can be written as a linear
combination of these vectors: For any vector \(v\), there are scalars \(câ‚, â€¦, câ‚™\) and vectors
\(bâ‚, â€¦, bâ‚™\) in â„¬ with \(v \;=\; câ‚Â·bâ‚ + â‹¯ + câ‚™Â·bâ‚™\). That is, a basis is a collection of â€˜building
blocksâ€™ for the vector space. Then any function \(f\) between basis sets immediately lifts to a
linear transformation (think vector space morphism) \(F\) as follows: Given a vector \(v\), since we
have a basis, we can express it as \(câ‚Â·bâ‚ + â‹¯ + câ‚™Â·bâ‚™\), now define
\(F v \;â‰”\; câ‚Â·(f\, bâ‚) + â‹¯ + câ‚™Â·(f\, bâ‚™)\).
</p>

<p>
Sweet!
</p>

<p>
Thus, to define a complicated linear transformation of vector
spaces, it more than suffices to define a plain old simple function of basis sets.
Moreover, by definition, such \(F\) maps basis vectors to basis vectors: \(f \;=\; Î¹ â¨¾ F\) where
\(Î¹ : â„¬ â†ª ğ’±\) is the inclusion that realises basis vectors as just usual vectors in the vector
space ğ’±.  <b>Slogan:</b>
<i>Vector space maps are determined by where they send their basis, and basis-vectors
are preserved.</i>
</p>

<p>
In the case of <code>(List A, ++, [])</code> we may consider <code>A</code> to be a â€˜basisâ€™ of the monoid &#x2014;indeed,
every list can be written as a linear combination of elements of <code>A</code>, given list
<code>[xâ‚, â€¦, xâ‚™] : List A</code> we have <code>[xâ‚, â€¦, xâ‚™] = xâ‚ + â‹¯ + xâ‚™</code> where <code>x + y â‰” [x] ++ [y]</code>.
Reasoning similarly as above, or if you have familiarity with <code>foldr , reduce</code>, we have a <b>slogan:</b>
<i>Monoid homomorphisms from lists are determined by where they send their basis and basis-vectors are preserved.</i>
</p>

<p>
Now the general case: <i>\(F âŠ£ U\) is a (free-forgetful) â€˜adjunctionâ€™</i> means
for functors â€˜forgetâ€™ \(U : ğ’ âŸ¶ ğ’®\) and â€˜freeâ€™ \(F : ğ’® â†’ ğ’\), we have that
for a given ğ’®imple-object \(S\) thereâ€™s ğ’®imple-map \(Î¹ : S âŸ¶_ğ’® U\,(F\, S)\) &#x2014;a way to realise â€˜basis
vectorsâ€™&#x2014; such that for any ğ’omplicated-object \(C\) and ğ’®imple-maps \(Ï† : S âŸ¶_ğ’® U\, C\), there is a
unique ğ’omplicated-map \(Î¦ : F\, S âŸ¶_ğ’ C\) that preserves the basis vectors: \(Ï† = Î¹ â¨¾ U Î¦\).
</p>

<p>
By analogy to the previous two cases, we may
consider \(U\, X\) to be a â€˜basisâ€™, and make the <b>slogan</b>:
ğ’omplicated-maps from free objects are
determined by where they send their basis and â€˜basis vectorsâ€™ are preserved.
</p>

<p>
[ In more categorical lingo, one says \(Î¹\) is the â€˜insertion of generatorsâ€™.
</p>

<p>
  Question: Does the way we took \(Î¹\) in the previous graph show that it is a natural
  transformation \(Î¹ : \Id âŸ¶ F â¨¾ U\)?
  &#x2014;The naturality just says that a â€˜homomorphismâ€™ \(F f\) on the free object is
  completely determined by what \(f\) does to the generators ;-)
]
</p>
</div>
</div>

<div id="outline-container-org9e118fa" class="outline-3">
<h3 id="Of-adjunctions">Of adjunctions</h3>
<div class="outline-text-3" id="text-Of-adjunctions">
<p>
An adjunction \(L âŠ£ U\), where the <code>L</code>-ower adjoint is from ğ’® to ğ’ and the <code>U</code>-pper adjoint is in
the opposite direction, lends itself to an elemntary interpretation if we consider ğ’
to be some universe of ğ’omplicated items of study, while ğ’® to be a universe of ğ’®imple
items of study. Then adjointness implies that given a simple-object \(S\) and a complicated-object
\(C\), a simple-map \(X âŸ¶ U\, C\) corresponds to a complicated-map \(L\, S âŸ¶ C\). To work with
complicated-maps it is more than enough to work with simple-maps!
</p>

<p>
Formally this correspondence, saying \(F : ğ’ âŸ¶ ğ’Ÿ\) is adjoint to \(G : ğ’Ÿ âŸ¶ ğ’\), written \(F âŠ£ G\),
holds precisely when \((F âˆ˜ X âŸ¶ Y) \;â‰…\; (X âŸ¶ G âˆ˜ Y)\) in a functor category:
</p>

<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8867;</span>&#8320;<span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> (i <span style="color: #268bd2;">&#8845;</span> j)
 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8867;</span>&#8320;<span style="color: #859900; font-weight: bold;">_</span> {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {<span style="color: #b58900; font-style: italic;">&#119967;</span>} <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">G</span>
    <span style="color: #268bd2;">=</span>
      (<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">&#8728;</span> <span style="color: #b58900; font-style: italic;">X</span>  <span style="color: #268bd2;">&#10230;</span>&#8345;&#8336;&#8348; <span style="color: #b58900; font-style: italic;">Y</span>)  <span style="color: #268bd2;">&#8773;</span>  (<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span>&#8345;&#8336;&#8348; <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#8728;</span> <span style="color: #b58900; font-style: italic;">Y</span>)  within  <span style="color: #b58900; font-style: italic;">Func</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> &#7506;&#7510; <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) <span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span>
   <span style="color: #859900; font-weight: bold;">where</span>
     <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Fst</span> ; <span style="color: #b58900; font-style: italic;">Y</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Snd</span> ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> opify <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">only changes types</span>

     <span style="color: #859900; font-weight: bold;">infix</span> 5 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span>&#8345;&#8336;&#8348;_
     <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span>&#8345;&#8336;&#8348;_ <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j} {<span style="color: #b58900; font-style: italic;">&#119964;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}} <span style="color: #268bd2;">&#8594;</span>
            <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> &#7506;&#7510; <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) (<span style="color: #b58900; font-style: italic;">&#119964;</span> &#7506;&#7510;) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> &#7506;&#7510; <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) <span style="color: #b58900; font-style: italic;">&#119964;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> &#7506;&#7510; <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) <span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span>
     <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span>&#8345;&#8336;&#8348;_ {i} {j} {<span style="color: #b58900; font-style: italic;">&#119964;</span>} <span style="color: #268bd2;">=</span> pointwise (<span style="color: #b58900; font-style: italic;">Hom</span> {i} {j} {<span style="color: #b58900; font-style: italic;">&#119964;</span>})
</pre>
</div>
<p>
Note that if we use Agda's built-in rewrite mechanism to add the rule,
</p>
<pre class="example">
{ğ’ ğ’Ÿ : Category {â„“â‚€} {â„“â‚€}} â†’ Functor (ğ’ áµ’áµ–) (ğ’Ÿ áµ’áµ–) â‰¡ Functor ğ’ ğ’Ÿ
</pre>
<p>
then we might be able to get away without using <code>opify</code>.
</p>

<p>
Anyhow, this says for any objects \(X\) and \(Y\), the collection of morphisms \((F\, A âŸ¶ B)\)
is isomorphic to the collection \((A âŸ¶ G\, B)\) and naturally so in \(A\) and \(B\).
</p>

<p>
Unfolding it, we have
</p>
<div class="org-src-container">
<pre class="src src-haskell"> record <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8867;</span><span style="color: #859900; font-weight: bold;">_</span> {i j i&#8217; j&#8217;} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}} {<span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i&#8217;} {j&#8217;}}
        (<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>)
        <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> (j&#8217; <span style="color: #268bd2;">&#8845;</span> i&#8217; <span style="color: #268bd2;">&#8845;</span> j <span style="color: #268bd2;">&#8845;</span> i) <span style="color: #859900; font-weight: bold;">where</span>

   open <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> renaming (<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> to <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span>&#8322;<span style="color: #859900; font-weight: bold;">_</span>)
   open <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> renaming (<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> to <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span>&#8321;<span style="color: #859900; font-weight: bold;">_</span>)
   field
     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8216;left-adjunct&#8217;  L &#8776; &#8970;  and  &#8216;right-adjunct&#8217;  r &#8776; &#8968;</span>
     &#8970;<span style="color: #859900; font-weight: bold;">_</span>&#8971; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">Y</span>} <span style="color: #268bd2;">&#8594;</span>   obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">Y</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>   <span style="color: #268bd2;">&#8594;</span>   <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span> obj <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">Y</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
     &#8968;<span style="color: #859900; font-weight: bold;">_</span>&#8969; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">Y</span>} <span style="color: #268bd2;">&#8594;</span>   <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span> obj <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">Y</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>   <span style="color: #268bd2;">&#8594;</span>   obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">Y</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>

     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Adjuncts are inverse operations</span>
     lid <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">Y</span>} {d <span style="color: #b58900; font-style: italic;">:</span> obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">Y</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>} <span style="color: #268bd2;">&#8594;</span> &#8968; &#8970; d &#8971; &#8969; <span style="color: #268bd2;">&#8801;</span> d
     rid <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">Y</span>} {c <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span> obj <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">Y</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">&#8594;</span> &#8970; &#8968; c &#8969; &#8971; <span style="color: #268bd2;">&#8801;</span> c

     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">That for a fixed argument, are natural transformations between Hom functors</span>
     lfusion <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #b58900; font-style: italic;">D</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {&#968; <span style="color: #b58900; font-style: italic;">:</span> obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>} {g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">D</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>}
             <span style="color: #268bd2;">&#8594;</span>  &#8970; mor <span style="color: #b58900; font-style: italic;">F</span> f <span style="color: #268bd2;">&#10814;</span>&#8322; &#968; <span style="color: #268bd2;">&#10814;</span>&#8322; g &#8971;  <span style="color: #268bd2;">&#8801;</span>  f <span style="color: #268bd2;">&#10814;</span>&#8321; &#8970; &#968; &#8971; <span style="color: #268bd2;">&#10814;</span>&#8321; mor <span style="color: #b58900; font-style: italic;">G</span> g
     rfusion <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #b58900; font-style: italic;">D</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {&#968; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#10230;</span> obj <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">D</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>}
             <span style="color: #268bd2;">&#8594;</span>  &#8968; f <span style="color: #268bd2;">&#10814;</span>&#8321; &#968; <span style="color: #268bd2;">&#10814;</span>&#8321; mor <span style="color: #b58900; font-style: italic;">G</span> g &#8969;  <span style="color: #268bd2;">&#8801;</span>  mor <span style="color: #b58900; font-style: italic;">F</span> f <span style="color: #268bd2;">&#10814;</span>&#8322; &#8968; &#968; &#8969; <span style="color: #268bd2;">&#10814;</span>&#8322; g
</pre>
</div>

<p>
This is easier for verifying an adjunction, while the former is easier for remembering and understanding what an adjunction actually is.
</p>

<p>
As the slogan goes â€˜adjunctions are everywhereâ€™.
They can be said to capture the notions of optimization and efficiency, but also that of simplicity.
</p>

<p>
For example, the supremum of a function is defined to be an upper bound of its image set and the least such bound.
Formally, this definition carries a few quantifiers and so a bit lengthy.
More elegantly, we can say the supremum operation is left-adjoint to the constant function: \[ \mathsf{sup} âŠ£ ğ’¦ \]
which means \[ âˆ€ z â€¢\qquad \mathsf{sup}\, f \,â‰¤\, z \quadâ‡”\quad f \overset{.}{â‰¤} ğ’¦\, z\]
Where \(ğ’¦\, x\, y \,=\, x\) and the \(\overset{.}{â‰¤}\) on the right is the point-wise ordering on functions.
This formulation of supremum is not only shorter to write but easier to use in calculational proofs.
</p>

<p>
For the efficiency bit, recall that it is efficient to specify a ğ’®imple-map, then use the adjuction, to obtain
a ğ’omplicated-map. Recall in the last paragraph how we define the super complicated notion of supremum of a function
in terms of the most elementary constant function!
</p>

<p>
Adjunctions over poset categories are called â€˜Galois connectionsâ€™ and a good wealth of
material on them can be found in nearly any writing by <a href="http://www.cs.nott.ac.uk/~psarb2/papers/papers.html">Backhouse et. al.</a>,
while a very accessible introduction is by <a href="http://www.cs.nott.ac.uk/~psarb2/MPC/galois.ps.gz">Aarts</a>,
and there is also an Agda mechanisation by <a href="http://relmics.mcmaster.ca/RATH-Agda/AContext-2.1.pdf">Kahl &amp; Al-hassy</a>.
</p>

<p>
Regarding forgetful functors:
Generally, but not always, forgetful functors are faithful and have left adjoints
&#x2014;because the notion of â€˜forgetâ€™ ought to have a corresponding notion of â€˜freeâ€™.
An exception to this is the category of fields, which has a forgetful functor to the
category of sets with no left adjoint.
</p>
</div>
</div>

<div id="outline-container-orgdbc5e6e" class="outline-3">
<h3 id="Adjunctions-and-Representable-Functors">Adjunctions and Representable Functors</h3>
<div class="outline-text-3" id="text-Adjunctions-and-Representable-Functors">
<p>
Another awesome thing about adjunctions <code>L âŠ£ U</code> is that they give us â€˜representable functorsâ€™,
  a.k.a. â€˜the best kind of functorsâ€™, when terminal objects exist.
</p>

<ul class="org-ul">
<li>An object <code>ğŸ™</code> is â€˜terminalâ€™ if for any object <code>A</code> there is a unique morphism <code>! {A} : A âŸ¶ ğŸ™</code>.
In ğ’®â„¯ğ“‰ we have <code>(A âŸ¶ ğŸ™) â‰… ğŸ™</code> and <code>(ğŸ™ âŸ¶ A) â‰… A</code>.</li>

<li>Specialising the adjunction, where <code>U : ğ’ âŸ¶ ğ’®eğ“‰</code>, to
a given set <code>A</code> and <code>ğŸ™</code> we obtain <code>(L ğŸ™ âŸ¶ A) â‰… (ğŸ™ âŸ¶ U A) â‰… U A</code> and so one says
â€˜ <code>U</code> is represented by <code>L ğŸ™</code> â€™.</li>

<li>In particular, if ğ’ is built on ğ’®â„¯ğ“‰ by adding some structure
and we are interested in utilising the elements of an object <code>A</code>
then it suffices to utilise the maps <code>L ğŸ™ âŸ¶ A</code>.</li>
</ul>

<p>
In the case of a free-forgetful adjunction, this says that
  <i>a forgetful functor is represented by the free object with generator <code>ğŸ™</code>.</i>
</p>

<p>
For example, for monoids the one-point monoid is the terminal object: <code>ğŸ™ â‰” ({*}, âŠ•, *)</code> with <code>x âŠ• y â‰” â‹†</code>.
Then every monoid-homomorphism from <code>ğŸ™</code> just picks out an element of the carrier of a monoid and so
<code>(ğŸ™ âŸ¶ M) â‰… ğ’° M</code> where <code>ğ’°</code> is the forgetful functor for monoids mentioned in the introduction.
</p>
</div>
</div>

<div id="outline-container-orgf1936a9" class="outline-3">
<h3 id="Concluding-remarks">Concluding remarks</h3>
<div class="outline-text-3" id="text-Concluding-remarks">
<p>
A final note about â€˜free objectsâ€™ &#x2014;arising from an adjoint to a forgetful functor.
</p>

<p>
<b>â€˜â€˜The free object is genericâ€™â€™</b>: The only truths provable for the free
object are precisely those that hold for every complicated-object.
</p>

<p>
(Begin squinting eyes)
 <br>
This follows from the
definition of adjunction which says we can construct a unique morphism between complicated-objects
from a simple-map and by naturality we may transport any proof for the free object to any
complicated object.
 <br>
(Feel â€˜freeâ€™ to stop squinting your eyes)
</p>


<p>
For futher reading consider reading the adjoint article at <a href="http://www.comicbooklibrary.org/articles/Left_adjoint">the comic book library</a>
and for more on the adjective â€˜forgetfulâ€™ see <a href="https://ncatlab.org/nlab/show/forgetful+functor">ncatlab</a> or <a href="http://mathworld.wolfram.com/ForgetfulFunctor.html">mathworld</a>
A nice list of common free objects can be found on <a href="https://en.wikipedia.org/wiki/Free_object#List_of_free_objects">wikipedia</a>.
</p>

<p>
You might be asking,
 <i>musa, when am I ever going to encounter this in daily life? In a popular setting?</i>
This concept is everywhere, even inclusions as mentioned earlier are an
instance. For the second question, enjoy listening to
<a href="https://www.youtube.com/watch?v=BipvGD-LCjU">this lovely musical group</a> &#x2013;they use the words â€˜forgetful functorsâ€™ ;)
</p>

<p>
The remainder of this document can be seen as one fully-worked out example of constructing a
free functor for the forgetful ğ’° defined above from ğ’ğ’¶ğ“‰ to ğ’¢ğ“‡ğ’¶ğ“…ğ’½.
</p>
</div>
</div>
</div>

<div id="outline-container-org1451e0d" class="outline-2">
<h2 id="Designing-Paths">Designing Paths</h2>
<div class="outline-text-2" id="text-Designing-Paths">
<div class="org-center">
<p>
<i>The â€œrightâ€ definition is hard to obtain!</i>
</p>
</div>
<p>
We can now define a â€˜pathâ€™ of length <code>n</code> in a graph <code>G</code> to be a graph-map
<code>[ n ] âŸ¶ G</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">Path</span>&#8320; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Graph</span>&#8320; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> (&#8467;suc &#8467;&#8320;)
<span style="color: #b58900; font-style: italic;">Path</span>&#8320; n <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">=</span> [ n ]&#8320; <span style="color: #b58900; font-style: italic;">&#119970;</span><span style="color: #268bd2;">&#10230;</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span>
</pre>
</div>

<p>
Unfolding the definition of graph-morphisms, this just says that a path of length <code>n</code>
consists of a sequence <code>[vâ‚€, vâ‚, vâ‚‚,  â€¦, vâ‚™]</code> of vertices of <code>G</code> and a sequence <code>[eâ‚€, eâ‚, â€¦, eâ‚™â‚‹â‚]</code>
of edges of <code>G</code> with typing <code>eáµ¢ : váµ¢ âŸ¶ váµ¢â‚Šâ‚</code>.
</p>

<p>
The definition is pretty slick! However, as the name suggests, perhaps we can concatenate paths
and itâ€™s not at all clear how to do this for the vertex- and edge- morphisms of the graph-maps
involved, whereas itâ€™s immediately clear how to do this with sequences: We just concatenate the
sequences and ensure the result is coherent.
</p>

<p>
Since the vertices can be obtained from the edges via <code>src</code> and <code>tgt</code>, we can dispense with them
and use the definition as outlined above.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Vec</span> using (<span style="color: #b58900; font-style: italic;">Vec</span> ; lookup)

<span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8321; (n <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span>) (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>&#8320;) <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> (&#8467;suc &#8467;&#8320;) <span style="color: #859900; font-weight: bold;">where</span>
  open <span style="color: #b58900; font-style: italic;">Graph</span>&#8320;
  field
    edges     <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Vec</span> (<span style="color: #b58900; font-style: italic;">E</span> <span style="color: #b58900; font-style: italic;">G</span>) (suc n)
    coherency <span style="color: #b58900; font-style: italic;">:</span> {i <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Fin</span> n} <span style="color: #268bd2;">&#8594;</span> tgt <span style="color: #b58900; font-style: italic;">G</span> (lookup (` i) edges) <span style="color: #268bd2;">&#8801;</span> src <span style="color: #b58900; font-style: italic;">G</span> (lookup (fsuc i) edges)
</pre>
</div>
<p>
That is, edges <code>[eâ‚€, â€¦, eâ‚™]</code> with coherency <code>tgt eáµ¢ â‰¡ src eáµ¢â‚Šâ‚</code>.
</p>

<p>
Great, weâ€™ve cut the definition of <code>Pathâ‚€</code> in half but that fact that we get a raw list of edges
and then need coherency to ensure that it is a well-formed path is still not terribly lovely.
After all, weâ€™re in Agda, weâ€™re among kings, we should be able to form the list in such a way that
the end result is a path. Letâ€™s do that!
</p>

<p>
Enough of this repetition, let us fix a graph <code>G</code>,
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">Path</span><span style="color: #268bd2;">-</span>definition<span style="color: #268bd2;">-</span>2 (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>&#8320;) <span style="color: #859900; font-weight: bold;">where</span>
  open <span style="color: #b58900; font-style: italic;">Graph</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span>

  mutual
    <span style="color: #859900; font-weight: bold;">data</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8322; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
      <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">!</span>   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8322;
      cons <span style="color: #b58900; font-style: italic;">:</span> (v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>) (e <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">E</span>) (ps <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8322;) (s <span style="color: #b58900; font-style: italic;">:</span> v <span style="color: #268bd2;">&#8801;</span> src e) (t <span style="color: #b58900; font-style: italic;">:</span> tgt e <span style="color: #268bd2;">&#8801;</span> head&#8322; ps) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8322;

    head&#8322; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8322; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span>
    head&#8322; (v <span style="color: #268bd2;">!</span>) <span style="color: #268bd2;">=</span> v
    head&#8322; (cons v e p s t) <span style="color: #268bd2;">=</span> v
</pre>
</div>

<p>
Defining paths for the parallel-pair approach to graphs leaves us with the need to carry
proofs around, and this is a tad too clunky in this case. Let's try yet again.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">Path</span><span style="color: #268bd2;">-</span>definition<span style="color: #268bd2;">-</span>3 (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>) <span style="color: #859900; font-weight: bold;">where</span>

  open <span style="color: #b58900; font-style: italic;">Graph</span> <span style="color: #b58900; font-style: italic;">G</span>

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">handy dandy syntax</span>
  <span style="color: #859900; font-weight: bold;">infixr</span> 5 cons
  syntax cons v ps e <span style="color: #268bd2;">=</span> v <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">v goes, by e, onto path ps</span>

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">we want well-formed paths</span>
  mutual
    <span style="color: #859900; font-weight: bold;">data</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
      <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">!</span>   <span style="color: #b58900; font-style: italic;">:</span> (v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323;
      cons <span style="color: #b58900; font-style: italic;">:</span> (v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>) (ps <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323;) (e <span style="color: #b58900; font-style: italic;">:</span> v <span style="color: #268bd2;">&#10230;</span> head&#8323; ps) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323;

    head&#8323; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span>
    head&#8323; (v <span style="color: #268bd2;">!</span>) <span style="color: #268bd2;">=</span> v
    head&#8323; (v <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps) <span style="color: #268bd2;">=</span> v

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">motivation for the syntax declaration above</span>
  example <span style="color: #b58900; font-style: italic;">:</span> (v&#8321; v&#8322; v&#8323; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>) (e&#8321; <span style="color: #b58900; font-style: italic;">:</span> v&#8321; <span style="color: #268bd2;">&#10230;</span> v&#8322;) (e&#8322; <span style="color: #b58900; font-style: italic;">:</span> v&#8322; <span style="color: #268bd2;">&#10230;</span> v&#8323;) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323;
  example v&#8321; v&#8322; v&#8323; e&#8321; e&#8322; <span style="color: #268bd2;">=</span> v&#8321; <span style="color: #268bd2;">&#10230;</span>[ e&#8321; ]<span style="color: #268bd2;">&#10230;</span> v&#8322; <span style="color: #268bd2;">&#10230;</span>[ e&#8322; ]<span style="color: #268bd2;">&#10230;</span> v&#8323; <span style="color: #268bd2;">!</span>

  end&#8323; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span>
  end&#8323; (v <span style="color: #268bd2;">!</span>) <span style="color: #268bd2;">=</span> v
  end&#8323; (v <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps) <span style="color: #268bd2;">=</span> end&#8323; ps

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">typed paths; squigarrowright</span>
  record <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8669;</span><span style="color: #859900; font-weight: bold;">_</span> (x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>) <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
    field
      path   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323;
      start  <span style="color: #b58900; font-style: italic;">:</span> head&#8323; path <span style="color: #268bd2;">&#8801;</span> x
      finish <span style="color: #b58900; font-style: italic;">:</span> end&#8323; path  <span style="color: #268bd2;">&#8801;</span> y
</pre>
</div>
<p>
This seems great, but thereâ€™s always room for improvement:
</p>


<ul class="org-ul">
<li><p>
Since the <code>cons</code> constructor's third argument depends on its first, we must
use a syntax declaration to get the desired look. Such aesthetic is not only
pleasing but reminiscent of diagrammatic paths;
moreover, itâ€™s guaranteed to be an actual path and not just an
alternating lists of vertices and edges.
Using the clunky <code>Pathâ‚‚</code>, weâ€™d write
</p>
<pre class="example">
  vâ‚ âŸ¶[ vâ‚â‰ˆseâ‚ , eâ‚ , teâ‚â‰ˆvâ‚‚ ]âŸ¶ vâ‚‚ âŸ¶[ vâ‚‚â‰ˆseâ‚‚ , eâ‚‚ , teâ‚‚â‰ˆvâ‚ƒ ]âŸ¶ vâ‚ƒ !
  where
  syntax cons v e ps s t = v âŸ¶[ s , e , t ]âŸ¶ ps
</pre>
<p>
yuck!
</p>

<p>
Finally, the syntax-declaration does not make the emacs agda-mode auto-case using
the syntax, and so I have to write it out by hand, each time I want to use the syntax.
</p></li>

<li>Again since <code>cons</code>'s third argument depends on the second argument, we need a mutual
definition to extract the item of the dependence. Perhaps if we embed this item at
the type level we may avoid the need of an auxiliary mutually-defined function.</li>

<li>By defining what the start and finish of a path are, we can assign types to it.
However, this approach is reminiscent of the parallel-pair approach to graphs,
as in <code>Graphâ‚€</code>, which we argued is less preferable to the typed-approach to graphs.
Perhaps defining paths with types by default, we can reap the benefits and simplicity
of the typed-approach to graphs.</li>
</ul>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">TypedPaths</span> (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>) <span style="color: #859900; font-weight: bold;">where</span>

  open <span style="color: #b58900; font-style: italic;">Graph</span> <span style="color: #b58900; font-style: italic;">G</span> hiding(<span style="color: #b58900; font-style: italic;">V</span>)
  open <span style="color: #b58900; font-style: italic;">Graph</span>   using (<span style="color: #b58900; font-style: italic;">V</span>)

  <span style="color: #859900; font-weight: bold;">data</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8669;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">!</span>      <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8669;</span> x
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span>[<span style="color: #859900; font-weight: bold;">_</span>]<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x {y &#969;} (e <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y) (ps <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#8669;</span> &#969;) <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8669;</span> &#969;
</pre>
</div>

<p>
One might think that since we can write
</p>
<pre class="example">
  src : {x y : V G} (e : x âŸ¶ y) â†’ V G
  src {x} {y} e = x
</pre>
<p>
we can again ignore vertices and it suffices to just keep a coherent list of edges.
Then what is an empty path at a vertex? Thisâ€™ enough to keep vertices around
&#x2014;moreover, the ensuing terms look like diagrammatic paths! Cool!
</p>

<div class="org-center">
<p>
Finding this definitional <i>form</i> was a major hurdle in this endeavour.
</p>
</div>
</div>

<div id="outline-container-org8a9444b" class="outline-3">
<h3 id="Aside-An-Adjunction-between-ğ’®â„¯ğ“‰-and-ğ’ğ’¶ğ“‰">Aside: An Adjunction between ğ’®â„¯ğ“‰ and ğ’ğ’¶ğ“‰</h3>
<div class="outline-text-3" id="text-Aside-An-Adjunction-between-ğ’®â„¯ğ“‰-and-ğ’ğ’¶ğ“‰">
<p>
With paths in hand, we can now consider a neat sequence of <a href="https://math.stackexchange.com/questions/1640298/coforgetful-functors">exercises</a> :-)
</p>

<ol class="org-ol">
<li><p>
Show that graphmaps preserve paths: <code>(f : G âŸ¶ H)  â†’ x â‡ y â†’ fáµ¥ x â‡ fáµ¥ y</code>;
this is nothing more than type-preservation for <code>f</code> to be a functor <code>ğ’«G âŸ¶ ğ’«H</code> ;)
</p>

<p>
Hint: This is <code>lift</code> from the next section.
</p></li>

<li><p>
Define
</p>
<pre class="example">
a connected b  â‰¡  (a â‡ b) âŠ (b â‡ a)  --  path â€œbetweenâ€ a and b; not â€˜from a to bâ€™.
</pre></li>

<li>This is an equivalence relation whose equivalence classes are called <i>the connected components of G</i>;
denote them by <code>ğ’¦G</code>.</li>

<li>For any category <code>ğ’</code>, define <code>ğ’¦ ğ’ â‰” ğ’¦ (ğ’°â‚€ ğ’)</code> which is a subcategory of <code>ğ’</code>.</li>

<li>Phrase the connected components subcategory using a universal property,
thereby avoiding the need for quotient types.</li>

<li>Since graphmaps preserve paths, every graph map can be extended to connected components,
<code>ğ’¦f : ğ’¦G âŸ¶ ğ’¦H : (connected component of x) â†¦ (connected component of fáµ¥ x)</code>.</li>

<li>Hence, we have a functor <code>ğ’¦ : Graph âŸ¶ Set</code>.</li>

<li><p>
Then there is a natural transformation <code>ğ’± âŸ¶ ğ’¦</code>, where ğ’± is the vertices functor.
</p>

<p>
Hint: Such a transformation means we can realise vertices as connected components and this suggests
taking assigning a vertex to the connected-component block that contains it.
</p>

<p>
yeah!
</p></li>
</ol>

<p>
Finally, if we let <code>ğ’Ÿ : ğ’®â„¯ğ“‰ â†’ ğ’ğ’¶ğ“‰</code> be the free category functor that associates each set with
the discrete category over it, then we have <code>ğ’¦</code> is the associated forgetful functor.
</p>
</div>
</div>

<div id="outline-container-org8f42427" class="outline-3">
<h3 id="Equality-Combinators-for-Paths">Equality Combinators for Paths</h3>
<div class="outline-text-3" id="text-Equality-Combinators-for-Paths">
<p>
Here's a handy-dandy combinator for forming certain equality proofs of paths.
</p>
<div class="org-src-container">
<pre class="src src-haskell">  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Preprend preserves path equality</span>
  <span style="color: #268bd2;">&#10230;-&#8801;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y &#969;} {e <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y} {ps qs <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#8669;</span> &#969;}
      <span style="color: #268bd2;">&#8594;</span> ps <span style="color: #268bd2;">&#8801;</span> qs <span style="color: #268bd2;">&#8594;</span> (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps) <span style="color: #268bd2;">&#8801;</span> (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> qs)
  <span style="color: #268bd2;">&#10230;-&#8801;</span> {x} {y} {&#969;} {e} {ps} {qs} eq <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>cong (&#955; r <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> r) eq
</pre>
</div>
<p>
Less usefully, we leave as exercises:
</p>
<pre class="example">
  edges : âˆ€ {x Ï‰} (p : x â‡ Ï‰) â†’ List (Î£ s âˆ¶ V G â€¢ Î£ t âˆ¶ V G â€¢ s âŸ¶ t)
  edges = {! exercise !}

  path-eq : âˆ€ {x y} {p q : x â‡ y} â†’ edges p â‰¡ edges q â†’ p â‰¡ q
  path-eq = {! exercise !}
</pre>
<p>
Given time, <code>path-eq</code> could be rewritten so as to be more easily applicable.
For now, two path equality proofs occur in the document and both are realised by
quick-and-easy induction.
</p>
</div>
</div>

<div id="outline-container-org32eca0e" class="outline-3">
<h3 id="Category-of-paths-over-a-graph">Category of paths over a graph</h3>
<div class="outline-text-3" id="text-Category-of-paths-over-a-graph">
<p>
Now we turn back to the problem of <a href="https://english.stackexchange.com/a/125659/327685">catenating</a> two paths.
</p>
<div class="org-src-container">
<pre class="src src-haskell">  <span style="color: #859900; font-weight: bold;">infixr</span> 5 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">++</span><span style="color: #859900; font-weight: bold;">_</span>

  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">++</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y z} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8669;</span> y <span style="color: #268bd2;">&#8594;</span> y <span style="color: #268bd2;">&#8669;</span> z <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8669;</span> z
  x <span style="color: #268bd2;">!</span> <span style="color: #268bd2;">++</span> q           <span style="color: #268bd2;">=</span> q                         <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">left unit</span>
  (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> p) <span style="color: #268bd2;">++</span> q <span style="color: #268bd2;">=</span> x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> (p <span style="color: #268bd2;">++</span> q)     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">mutual-associativity</span>
</pre>
</div>
<p>
Notice that the the base case indicate that <code>!</code> forms a left-unit for <code>++</code>,
while the inductive case says that path-formation associates with path catenation.
Both observations also hold for the definition of list catenation ;-)
</p>

<p>
If we had not typed our paths, as in <code>Pathâ‚‚</code>, we would need to carry around a
proof that paths are compatible for concatenation:
</p>
<pre class="example">
  catenate : (p q : Path) (coh : end p â‰¡ head q) â†’ Path
  syntax catenate p q compatibility = p ++[ compatibility ] q
</pre>
<p>
Even worse, to show <code>p ++[ coh ] q â‰¡ p ++[ cohâ€™ ] q</code> we need to invoke proof-irrelevance of
identity proofs to obtain <code>coh â‰¡ cohâ€™</code>, each time we want such an equality! Moving the proof
obligation to the type level removes this need.
</p>

<p>
As can be seen, being type-less is a terrible ordeal.
</p>

<p>
Just as the first clause of <code>_++_</code> indicates <code>_!</code> is a left unit,
</p>
<div class="org-src-container">
<pre class="src src-haskell">  leftId <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {x y} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">!</span> <span style="color: #268bd2;">++</span> p <span style="color: #268bd2;">&#8801;</span> p
  leftId <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
</pre>
</div>
<p>
Is it also a right identity?
</p>
<div class="org-src-container">
<pre class="src src-haskell">  rightId <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {x y} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y} <span style="color: #268bd2;">&#8594;</span> p <span style="color: #268bd2;">++</span> y <span style="color: #268bd2;">!</span> <span style="color: #268bd2;">&#8801;</span> p
  rightId {x} {<span style="color: #268bd2;">.</span>x} {<span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
  rightId {x} {y } {<span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>cong (&#955; q <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> q) rightId
</pre>
</div>

<p>
Is this operation associative?
</p>
<div class="org-src-container">
<pre class="src src-haskell">  assoc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y z &#969;} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y} {q <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#8669;</span> z} {r <span style="color: #b58900; font-style: italic;">:</span> z <span style="color: #268bd2;">&#8669;</span> &#969;}
        <span style="color: #268bd2;">&#8594;</span> (p <span style="color: #268bd2;">++</span> q) <span style="color: #268bd2;">++</span> r <span style="color: #268bd2;">&#8801;</span> p <span style="color: #268bd2;">++</span> (q <span style="color: #268bd2;">++</span> r)
  assoc {x} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
  assoc {x} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} {q} {r} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>cong (&#955; s <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> s) (assoc {p <span style="color: #268bd2;">=</span> ps})
</pre>
</div>

<p>
Hence, weâ€™ve shown that the paths over a graph <code>G</code> constitute a category! Letâ€™s call it <code>ğ’« G</code>.
</p>
</div>
</div>

<div id="outline-container-orgc341582" class="outline-3">
<h3 id="The-ğ’«ath-to-freedom">The ğ’«ath to freedom</h3>
<div class="outline-text-3" id="text-The-ğ’«ath-to-freedom">
<p>
In the last section, we showed that the paths over a graph make a category,
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Category</span>
<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">let</span> open <span style="color: #b58900; font-style: italic;">TypedPaths</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #859900; font-weight: bold;">in</span>
    record
      { <span style="color: #b58900; font-style: italic;">Obj</span>     <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span>
      ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span>     <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8669;</span><span style="color: #859900; font-weight: bold;">_</span>
      ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>     <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">++</span><span style="color: #859900; font-weight: bold;">_</span>
      ; assoc   <span style="color: #268bd2;">=</span> &#955; {x y z &#969; p q r} <span style="color: #268bd2;">&#8594;</span> assoc {p <span style="color: #268bd2;">=</span> p}
      ; <span style="color: #b58900; font-style: italic;">Id</span>      <span style="color: #268bd2;">=</span> &#955; {x} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">!</span>
      ; leftId  <span style="color: #268bd2;">=</span> leftId
      ; rightId <span style="color: #268bd2;">=</span> rightId
      }
</pre>
</div>

<p>
Can we make <code>ğ’«</code> into a functor by defining it on morphisms?
That is, to lift graph-maps to category-maps, i.e., functors.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">GraphMap</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span>) (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">H</span>)
<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; {<span style="color: #b58900; font-style: italic;">G</span>} {<span style="color: #b58900; font-style: italic;">H</span>} f <span style="color: #268bd2;">=</span> record
    { obj  <span style="color: #268bd2;">=</span> ver f
    ; mor  <span style="color: #268bd2;">=</span> amore
    ; id   <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
    ; comp <span style="color: #268bd2;">=</span> &#955; {x} {y} {z} {p} <span style="color: #268bd2;">&#8594;</span> comp {p <span style="color: #268bd2;">=</span> p}
    }
    <span style="color: #859900; font-weight: bold;">where</span>
      open <span style="color: #b58900; font-style: italic;">TypedPaths</span> &#10627;<span style="color: #268bd2;">...</span>&#10628; public
      <span style="color: #859900; font-weight: bold;">instance</span> <span style="color: #b58900; font-style: italic;">G'</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span> ; <span style="color: #b58900; font-style: italic;">G'</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">G</span>
               <span style="color: #b58900; font-style: italic;">H'</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span> ; <span style="color: #b58900; font-style: italic;">H'</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">H</span>

      amore <span style="color: #b58900; font-style: italic;">:</span> {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span>} <span style="color: #268bd2;">&#8594;</span>  x <span style="color: #268bd2;">&#8669;</span> y <span style="color: #268bd2;">&#8594;</span> (ver f x) <span style="color: #268bd2;">&#8669;</span> (ver f y)
      amore (x <span style="color: #268bd2;">!</span>) <span style="color: #268bd2;">=</span> ver f x <span style="color: #268bd2;">!</span>
      amore (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> p) <span style="color: #268bd2;">=</span> ver f x <span style="color: #268bd2;">&#10230;</span>[ edge f e ]<span style="color: #268bd2;">&#10230;</span> amore p

      comp <span style="color: #b58900; font-style: italic;">:</span> {x y z <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span>} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y} {q <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#8669;</span> z}
          <span style="color: #268bd2;">&#8594;</span>  amore (p <span style="color: #268bd2;">++</span> q)  <span style="color: #268bd2;">&#8801;</span>  amore p <span style="color: #268bd2;">++</span> amore q
      comp {x} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">since ! is left unit of ++</span>
      comp {x} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#10230;-&#8801;</span> (comp {p <span style="color: #268bd2;">=</span> ps})
</pre>
</div>
<p>
Sweet!
</p>

<p>
With these two together, we have that <code>ğ’«</code> is a functor.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">&#119979;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span> <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span>
<span style="color: #b58900; font-style: italic;">&#119979;</span> <span style="color: #268bd2;">=</span> record { obj   <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320;
            ; mor  <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321;
            ; id   <span style="color: #268bd2;">=</span> &#955; {<span style="color: #b58900; font-style: italic;">G</span>} <span style="color: #268bd2;">&#8594;</span> funcext <span style="color: #268bd2;">&#8801;-</span>refl (id &#10627; <span style="color: #b58900; font-style: italic;">G</span> &#10628;)
            ; comp <span style="color: #268bd2;">=</span> funcext <span style="color: #268bd2;">&#8801;-</span>refl comp
            }
    <span style="color: #859900; font-weight: bold;">where</span>
      open <span style="color: #b58900; font-style: italic;">TypedPaths</span> &#10627;<span style="color: #268bd2;">...</span>&#10628;
      open <span style="color: #b58900; font-style: italic;">Category</span>   &#10627;<span style="color: #268bd2;">...</span>&#10628;

      <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span>   <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span>
      <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span>

      id <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> &#10627; <span style="color: #b58900; font-style: italic;">G</span> &#10628; {x y} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y}
        <span style="color: #268bd2;">&#8594;</span>   mor (<span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Id</span> {<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span>}) p  <span style="color: #268bd2;">&#8801;</span>  mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; (<span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Id</span>)) p
      id {p <span style="color: #268bd2;">=</span> x <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
      id {p <span style="color: #268bd2;">=</span> x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#10230;-&#8801;</span> (id {p <span style="color: #268bd2;">=</span> ps})

      comp <span style="color: #b58900; font-style: italic;">:</span> {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">K</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">GraphMap</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span>} {g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">GraphMap</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">K</span>}
           <span style="color: #268bd2;">&#8594;</span> {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span>} {p <span style="color: #b58900; font-style: italic;">:</span> TypedPaths._<span style="color: #268bd2;">&#8669;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">G</span> x y}
           <span style="color: #268bd2;">&#8594;</span>  mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; f <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g) p  <span style="color: #268bd2;">&#8801;</span>  mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; (f <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> g)) p
      comp {p <span style="color: #268bd2;">=</span> x <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
      comp {p <span style="color: #268bd2;">=</span> x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#10230;-&#8801;</span> (comp {p <span style="color: #268bd2;">=</span> ps})
</pre>
</div>

<p>
It seemed prudent in this case to explicitly delimit where the compositions lives
&#x2014;this is for clarity, since Agda can quickly resolve the appropriate category instances.
</p>

<p>
Exercise: Show that we have a natural transformation <code>Id âŸ¶ ğ’° âˆ˜ ğ’«</code>.
</p>
</div>
</div>
</div>
<div id="outline-container-org493785c" class="outline-2">
<h2 id="Free-at-last">Free at last</h2>
<div class="outline-text-2" id="text-Free-at-last">
<blockquote>
<p>
Free at last, free at last, thank God almighty we are free at last.
</p>

<p>
&#x2013; Martin Luther King Jr.
</p>
</blockquote>

<p>
Recall why lists give the â€˜free monoidâ€™: We can embed a type \(A\) into \(\List A\) by the map \([\_{}]\),
and we can lift any map \(f : A âŸ¶ B\) to a monoid map
\[\foldr \; (Î» a b â†’ f\, a âŠ• b)\; e \;:\; (\List A ,\_{}++\_{} , []) \,âŸ¶\, (B,\_{}âŠ•\_{} , e)\]
I.e., \([aâ‚, â€¦, aâ‚–] \;â†¦\; f\, aâ‚ âŠ• â‹¯ âŠ• f\, aâ‚–\). Moreover
this â€˜preserves the basisâ€™ \(A\)
&#x2013; i.e., \(âˆ€ a â€¢\; f\, a \,=\, \foldr \,f \,e \, [ a ]\) &#x2013;
and this lifted map is unique.
</p>

<p>
Likewise, let us show that \(ğ’«G\) is the â€˜free categoryâ€™ over the graph \(G\).
This amounts to saying that there is a way, a graph-map, say \(Î¹\), that embeds \(G\) into \(ğ’«G\),
and a way to lift any graph-map \(f \,:\, G \,ğ’¢âŸ¶\, ğ’°â‚€ ğ’\) to a functor \(\mathsf{lift}\, f : ğ’«G âŸ¶ ğ’\)
that â€˜preserves the basisâ€™ \(f \;=\; Î¹ â¨¾ ğ’°â‚ (\mathsf{lift}\, f)\) and uniquely so.
</p>

<p>
Letâ€™s begin!
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> freedom (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span>) {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {&#8467;&#8320;} {&#8467;&#8320;} } <span style="color: #859900; font-weight: bold;">where</span>

  open <span style="color: #b58900; font-style: italic;">TypedPaths</span> <span style="color: #b58900; font-style: italic;">G</span> using (<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">!</span> ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span>[<span style="color: #859900; font-weight: bold;">_</span>]<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> ;  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8669;</span><span style="color: #859900; font-weight: bold;">_</span> ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">++</span><span style="color: #859900; font-weight: bold;">_</span>)
  open <span style="color: #b58900; font-style: italic;">Category</span> &#10627;<span style="color: #268bd2;">...</span>&#10628;

  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span>
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> (<span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span> {&#8467;&#8320;})
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
  <span style="color: #859900; font-weight: bold;">instance</span> <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
</pre>
</div>
</div>

<div id="outline-container-org53f94c6" class="outline-3">
<h3 id="Defining-the-needed-operations">Defining the needed operations</h3>
<div class="outline-text-3" id="text-Defining-the-needed-operations">
<p>
The only obvious, and most natural, way to embed a graph into its â€˜graph of pathsâ€™ is to send
vertices to vertices and edges to paths of length 1.
</p>

<div class="org-src-container">
<pre class="src src-haskell">  &#953; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span>)
  &#953; <span style="color: #268bd2;">=</span> record { ver <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Id</span> ; edge <span style="color: #268bd2;">=</span> &#955; {x} {y} e  <span style="color: #268bd2;">&#8594;</span>  x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> (y <span style="color: #268bd2;">!</span>) }
</pre>
</div>

<p>
Given a graph map \(f\), following the list-analagoue of \([aâ‚, â€¦, aâ‚–] \;â†¦\; f\, aâ‚ âŠ• â‹¯ âŠ• f\, aâ‚–\)
we attempt to lift the map onto paths by taking the edges \(eâ‚, â€¦, eâ‚–\) of a path
to a morphism \(\edge\, f\, eâ‚ â¨¾ â‹¯ â¨¾ \edge\, f\, eâ‚–\).
That is, a path of the form
\[x_0 \xrightarrow{e_1} x_1 \xrightarrow{e_2} x_2 \xrightarrow{e_3} â‹¯ \xrightarrow{e_k} x_k \]
Is lifted to the composition of morphisms
\[\mathsf{ver}\, f\, x_0 \xrightarrow{\edge\, f\, e_1}
   \mathsf{ver}\, f\, x_1 \xrightarrow{\edge\, f\, e_2}
   \mathsf{ver}\, f\, x_2 \xrightarrow{\edge\, f\, e_3} â‹¯ \xrightarrow{\edge\, f\, e_k}
   \mathsf{ver}\, f\, x_k \]
</p>

<p>
Of course, we then need to verify that this construction is indeed
functorial.
</p>

<div class="org-src-container">
<pre class="src src-haskell">  lift <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">&#119966;</span>  <span style="color: #268bd2;">&#8594;</span>  <span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
  lift f <span style="color: #268bd2;">=</span> record
     { obj  <span style="color: #268bd2;">=</span> &#955; v <span style="color: #268bd2;">&#8594;</span> ver f v <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Only way to obtain an object of &#119966;; hope it works!</span>
     ; mor  <span style="color: #268bd2;">=</span> fmap
     ; id   <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
     ; comp <span style="color: #268bd2;">=</span> &#955; {x y z p q} <span style="color: #268bd2;">&#8594;</span> proof {x} {y} {z} {p} {q}
     }
     <span style="color: #859900; font-weight: bold;">where</span>
          fmap <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {x y} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8669;</span> y <span style="color: #268bd2;">&#8594;</span> ver f x <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10230;</span> ver f y
          fmap (y <span style="color: #268bd2;">!</span>) <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Id</span>
          fmap (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> p) <span style="color: #268bd2;">=</span> edge f e <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> fmap p

          <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">homomorphism property</span>
          proof <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y z} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y} {q <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#8669;</span> z} <span style="color: #268bd2;">&#8594;</span> fmap (p <span style="color: #268bd2;">++</span> q) <span style="color: #268bd2;">&#8801;</span> fmap p <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> fmap q
          proof {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>sym <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.</span>leftId
          proof {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} <span style="color: #268bd2;">=</span>  <span style="color: #268bd2;">&#8801;-</span>cong (&#955; m <span style="color: #268bd2;">&#8594;</span> edge f e <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> m) (proof {p <span style="color: #268bd2;">=</span> ps})
                                     &#10216;<span style="color: #268bd2;">&#8801;&#8801;</span>&#10217; <span style="color: #268bd2;">&#8801;-</span>sym assoc
                                     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Exercise: Rewrite this calculationally!</span>
</pre>
</div>

<p>
Now we have the embedding and the lifting, it remains to show that the aforementioned
â€˜preserves basisâ€™ property holds as does uniqueness.
</p>
</div>
</div>

<div id="outline-container-orgbc349b2" class="outline-3">
<h3 id="Realising-the-proof-obligations">Realising the proof-obligations</h3>
<div class="outline-text-3" id="text-Realising-the-proof-obligations">
<p>
Let's begin with the â€˜basis preservationâ€™ property:
</p>

<div class="org-src-container">
<pre class="src src-haskell">  property <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">&#119966;</span>}  <span style="color: #268bd2;">&#8594;</span>  f  <span style="color: #268bd2;">&#8801;</span>  (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; (lift f))
  property {f} <span style="color: #268bd2;">=</span> graphmapext
    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Proving: &#8704; {v} &#8594; ver f v &#8801; ver (&#953; &#119966;.&#10814; &#119984;&#8321; (lift f)) v</span>
    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">by starting at the complicated side and simplifying</span>
    (&#955; {v} <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8801;-</span>sym (begin
              ver (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; (lift f)) v
            <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of ver on composition "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
              (ver &#953; <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> ver (<span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; (lift f))) v
            <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of &#119984;&#8321; says: ver (&#119984;&#8321; F) = obj F "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
              (ver &#953; <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> obj (lift f)) v
            <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of lift says: obj (lift f) = ver f "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
              (ver &#953; <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> ver f) v
            <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of &#953; on vertices is identity "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
              ver f v
            <span style="color: #268bd2;">&#8718;</span>))

    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Proving: edge (&#953; &#10814;g &#119984;&#8321; (lift f)) e &#8801; edge f e</span>
    (&#955; {x} {y} {e} <span style="color: #268bd2;">&#8594;</span> begin
               edge (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; (lift f)) e
             <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of edge on composition "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
               (edge &#953; <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> edge (<span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; (lift f))) e
             <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of &#119984; says: edge (&#119984;&#8321; F) = mor F "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
               (edge &#953; <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> mor (lift f)) e
             <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition chasing gives: mor (lift f) (edge &#953; e) = edge f e &#10814; Id "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
               edge f e <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span>
             <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.</span>rightId &#10217;
               edge f e
             <span style="color: #268bd2;">&#8718;</span>)
</pre>
</div>

<p>
Observe that we simply chased definitions and as such <code>graphmapext â‰¡-refl rightId</code> suffices as a proof,
but itâ€™s not terribly clear why, for human consumption, and so we choose to elaborate with the
detail.
</p>

<p>
Finally, it remains to show that there is a unique way to preserve â€˜basisâ€™:
</p>

<div class="org-src-container">
<pre class="src src-haskell">  uniqueness <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">&#119966;</span>} {<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">&#8594;</span> f <span style="color: #268bd2;">&#8801;</span> (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>) <span style="color: #268bd2;">&#8594;</span> lift f <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">F</span>
  uniqueness {<span style="color: #268bd2;">.</span>(&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)} {<span style="color: #b58900; font-style: italic;">F</span>} <span style="color: #268bd2;">&#8801;-</span>refl <span style="color: #268bd2;">=</span> funcext <span style="color: #268bd2;">&#8801;-</span>refl (<span style="color: #268bd2;">&#8801;-</span>sym pf)
    <span style="color: #859900; font-weight: bold;">where</span>
      pf <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y} <span style="color: #268bd2;">&#8594;</span>  mor (lift (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)) p  <span style="color: #268bd2;">&#8801;</span>  mor <span style="color: #b58900; font-style: italic;">F</span> p
      pf {x} {<span style="color: #268bd2;">.</span>x} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>sym (Functor.id <span style="color: #b58900; font-style: italic;">F</span>)
      pf {x} {y} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} <span style="color: #268bd2;">=</span> begin
         mor (lift (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)) (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps)
       <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of mor on lift, the inductive clause "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
         edge (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>) e <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> mor (lift (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)) ps
       <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #268bd2;">&#8801;-</span>cong&#8322; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">&#8801;-</span>refl (pf {p <span style="color: #268bd2;">=</span> ps}) &#10217; <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">inductive step</span>
         edge (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>) e <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span> ps
       <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of edge says it preserves composition "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
         (edge &#953; <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> edge (<span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)) e <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span> ps
       <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of &#119984; gives: edge (&#119984;&#8321; F) = mor F "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
         (edge &#953; <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span>) e <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span> ps
       <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of functional composition &#119982;&#8495;&#120009; "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
          mor <span style="color: #b58900; font-style: italic;">F</span> (edge &#953; e) <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span> ps
       <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #268bd2;">&#8801;-</span>sym (Functor.comp <span style="color: #b58900; font-style: italic;">F</span>) <span style="color: #96A7A9; font-style: italic;">{- </span><span style="color: #96A7A9; font-style: italic;">i.e., functors preserve composition -}</span> &#10217;
          mor <span style="color: #b58900; font-style: italic;">F</span> (edge &#953; e <span style="color: #268bd2;">++</span> ps)
       <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of embedding and concatenation "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
         mor <span style="color: #b58900; font-style: italic;">F</span> (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps)
       <span style="color: #268bd2;">&#8718;</span>
</pre>
</div>

<p>
Challenge:
Define graph-map equality â€˜â‰ˆgâ€™ by <i>extensionality</i> &#x2013;two graph maps are equal iff
their vertex <i>and</i> edge maps are extensionally equal. This is far more relaxed
than using propositional equality â€˜â‰¡â€™. Now show the stronger uniqueness claim:
</p>
<pre class="example">
âˆ€{f : G âŸ¶ ğ’°â‚€ ğ’} {F : ğ’«â‚€ G âŸ¶ ğ’}   â†’   f  â‰ˆg  (Î¹ â¨¾ ğ’°â‚ F)   â†’   lift f  â‰¡  F
</pre>
</div>
</div>

<div id="outline-container-org55844ea" class="outline-3">
<h3 id="Another-freedom-proof">Another freedom proof</h3>
<div class="outline-text-3" id="text-Another-freedom-proof">
<p>
However, saying each graph-map gives rise to exactly one unique functor is tantamount to
saying the type <code>GraphMap G (ğ’°â‚€ ğ’)</code> is isomorphic to <code>Functor (ğ’«â‚€ G) ğ’</code>, that is
<code>(ğ’«â‚€ G âŸ¶ ğ’) â‰… (G âŸ¶ ğ’°â‚€ ğ’)</code> &#x2014;observe that this says we can â€˜moveâ€™ <code>ğ’«â‚€</code> from the left to
the right of an arrow at the cost of it (and the arrow) changing.
</p>

<p>
A few healthy exercises,
</p>

<pre class="example">
  liftË˜ : Functor ğ’«G ğ’ â†’ GraphMap G (ğ’°â‚€ ğ’)
  liftË˜ F = Î¹ â¨¾g ğ’°â‚ F  --  i.e., record {ver = obj F , edge = mor F âˆ˜ edge Î¹}

  rid : âˆ€{f : GraphMap G (ğ’°â‚€ ğ’)} â†’ âˆ€{x y} {e : x âŸ¶g y} â†’ liftË˜ (lift f) â‰¡ f
  rid = {! exercise !}

  lid : âˆ€{F : Functor ğ’«G ğ’} â†’ lift (liftË˜ F) â‰¡ F
  lid = {! exercise !}
</pre>

<p>
One can of course obtain these proofs from the other ones without recourse to definitions,
however for comprehension one would do well to prove them from first principles.
The worked out solutions are available in the literate source file of this document.
</p>

<p>
We can then provide an alternative, and more succinct, proof of uniqueness for â€˜basis preservationâ€™:
</p>

<div class="org-src-container">
<pre class="src src-haskell">  uniqueness&#8217;  <span style="color: #b58900; font-style: italic;">:</span>  <span style="color: #268bd2;">&#8704;</span>{f h}   <span style="color: #268bd2;">&#8594;</span>    f  <span style="color: #268bd2;">&#8801;</span>  (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; h)   <span style="color: #268bd2;">&#8594;</span>   lift f  <span style="color: #268bd2;">&#8801;</span>  h
  uniqueness&#8217; {f} {h} f<span style="color: #268bd2;">&#8776;</span>&#953;<span style="color: #268bd2;">&#10814;</span><span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321;h <span style="color: #268bd2;">=</span> begin
      lift f
    <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #268bd2;">&#8801;-</span>cong lift f<span style="color: #268bd2;">&#8776;</span>&#953;<span style="color: #268bd2;">&#10814;</span><span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321;h &#10217;
      lift (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; h)
    <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of lift&#728; "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
      lift (lift<span style="color: #268bd2;">&#728;</span> h)
    <span style="color: #268bd2;">&#8801;</span>&#10216; lid &#10217;
      h
    <span style="color: #268bd2;">&#8718;</span>
</pre>
</div>

<p>
The difference between this proof and the original one is akin
to the difference between heaven and earth! That or it's much more elegant ;-)
</p>
</div>
</div>

<div id="outline-container-org1af54d0" class="outline-3">
<h3 id="ğ’«-ğ’°"><code>ğ’« âŠ£ ğ’°</code></h3>
<div class="outline-text-3" id="text-ğ’«-ğ’°">
<p>
Thus far, we have essentially shown
\[(ğ’«â‚€\, G \,âŸ¶\, ğ’) \quadâ‰…\quad (G \,âŸ¶\, ğ’°â‚€\, ğ’)\]
We did so by finding a pair of inverse maps:
</p>

<pre class="example">
lift   :  (    G âŸ¶ ğ’°â‚€ ğ’)  â†’  (ğ’«â‚€ G âŸ¶     ğ’)
liftË˜  :  (ğ’«â‚€ G  âŸ¶    ğ’)  â†’  (   G âŸ¶  ğ’°â‚€ ğ’)
</pre>

<p>
This is nearly <code>ğ’« âŠ£ ğ’°</code> which implies <code>ğ’«</code> is a â€˜free-functorâ€™ since it is left-adjoint to a forgetful-functor.
</p>

<p>
â€˜Nearlyâ€™ since we need to exhibit naturality:
For every graph map <code>g</code> and functors <code>F, k</code> we have
<code>liftË˜ (ğ’« g â¨¾ k â¨¾ F) â‰ˆ g â¨¾ liftË˜ k â¨¾ ğ’° F</code> in the category of graphs.
</p>

<p>
<a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">Fokkinga (Theorem A.4)</a>, among others, would call these laws â€˜fusionâ€™
instead since they inform us how to compose, or â€˜fuseâ€™, a morphism with a
<code>liftË˜</code>-ed morphism: Taking <code>F</code> to be the identity and remembering that functors preserve
identities, we have that <code>g â¨¾ liftË˜ K â‰¡ liftË˜( ğ’«â‚ g â¨¾ K)</code> &#x2013;we can push a morphism into a <code>liftË˜</code>
at the cost of introducing a <code>ğ’«â‚</code>; dually for <code>lift</code>-ed morphisms.
</p>

<p>
First the setup,
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #859900; font-weight: bold;">_</span> {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {&#8467;&#8320;} {&#8467;&#8320;}}
          (g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">GraphMap</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span>) (<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) <span style="color: #859900; font-weight: bold;">where</span>

  private
    lift<span style="color: #268bd2;">&#728;</span> <span style="color: #268bd2;">=</span> &#955; {<span style="color: #b58900; font-style: italic;">A</span>} {<span style="color: #b58900; font-style: italic;">C</span>} <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8594;</span> freedom<span style="color: #268bd2;">.</span>lift<span style="color: #268bd2;">&#728;</span> <span style="color: #b58900; font-style: italic;">A</span> {<span style="color: #b58900; font-style: italic;">C</span>} <span style="color: #b58900; font-style: italic;">B</span>
    lift <span style="color: #268bd2;">=</span> &#955; {<span style="color: #b58900; font-style: italic;">A</span>} {<span style="color: #b58900; font-style: italic;">C</span>} <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8594;</span> freedom<span style="color: #268bd2;">.</span>lift <span style="color: #b58900; font-style: italic;">A</span> {<span style="color: #b58900; font-style: italic;">C</span>} <span style="color: #b58900; font-style: italic;">B</span>
  open <span style="color: #b58900; font-style: italic;">Category</span> &#10627;<span style="color: #268bd2;">...</span>&#10628;

  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>     <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>     <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span>
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span>   <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> (<span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span> {&#8467;&#8320;} {&#8467;&#8320;})
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span>   <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> (<span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span> {&#8467;&#8320;})
</pre>
</div>

<p>
Just as we needed to prove two inverse laws for <code>lift</code> and <code>liftË˜</code>,
we need two naturality proofs.
</p>

<div class="org-src-container">
<pre class="src src-haskell">  naturality<span style="color: #268bd2;">&#728;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">K</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">H</span>) <span style="color: #b58900; font-style: italic;">&#119966;</span>}
              <span style="color: #268bd2;">&#8594;</span>  lift<span style="color: #268bd2;">&#728;</span> (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">K</span> <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">F</span>)  <span style="color: #268bd2;">&#8801;</span>  (g <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> lift<span style="color: #268bd2;">&#728;</span> <span style="color: #b58900; font-style: italic;">K</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)
  naturality<span style="color: #268bd2;">&#728;</span> <span style="color: #268bd2;">=</span> graphmapext <span style="color: #268bd2;">&#8801;-</span>refl <span style="color: #268bd2;">&#8801;-</span>refl
</pre>
</div>

<p>
That was easier than assumed!
Hahaha: Hard to formalise but so easy to prove lolz!
It says we can â€˜shuntâ€™ <code>liftË˜</code> into certain compositions at the cost
of replacing functor instances.
</p>

<p>
Now for the other proof:
</p>
<div class="org-src-container">
<pre class="src src-haskell">  naturality <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {k <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">GraphMap</span> <span style="color: #b58900; font-style: italic;">H</span> (<span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">&#119966;</span>)} <span style="color: #268bd2;">&#8594;</span>     lift (g <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> k <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)
                                              <span style="color: #268bd2;">&#8801;</span>  (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> lift k <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">F</span>)
  naturality {k} <span style="color: #268bd2;">=</span> funcext <span style="color: #268bd2;">&#8801;-</span>refl (&#955; {x y p} <span style="color: #268bd2;">&#8594;</span> proof {x} {y} {p})
    <span style="color: #859900; font-weight: bold;">where</span>
      open <span style="color: #b58900; font-style: italic;">TypedPaths</span> &#10627;<span style="color: #268bd2;">...</span>&#10628;
      <span style="color: #859900; font-weight: bold;">instance</span> <span style="color: #b58900; font-style: italic;">G</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span> ; <span style="color: #b58900; font-style: italic;">G</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">G</span>
               <span style="color: #b58900; font-style: italic;">H</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span> ; <span style="color: #b58900; font-style: italic;">H</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">H</span>
      proof <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span>} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y}
            <span style="color: #268bd2;">&#8594;</span>    mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">F</span>) p
               <span style="color: #268bd2;">&#8801;</span>  mor (lift {<span style="color: #b58900; font-style: italic;">G</span>} {<span style="color: #b58900; font-style: italic;">&#119967;</span>} (g <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> k <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)) p
      proof {p <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> functor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">F</span>) preserves<span style="color: #268bd2;">-</span>identities
      proof {p <span style="color: #268bd2;">=</span> x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} <span style="color: #268bd2;">=</span> begin
            mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">F</span>) (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps)
         <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" By definition, &#8220;mor&#8221; distributes over composition "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
            (mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g) <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> mor (lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k) <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span>) (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps)
         <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" Definitions of function composition and &#8220;&#119979;&#8321; &#10814; mor&#8221; "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
            mor <span style="color: #b58900; font-style: italic;">F</span> (mor (lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k) (mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g) (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps)))
                                                  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">This explicit path is in G</span>
         <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" Lifting graph-map &#8220;g&#8221; onto a path "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
            mor <span style="color: #b58900; font-style: italic;">F</span> (mor (lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k) (ver g x <span style="color: #268bd2;">&#10230;</span>[ edge g e ]<span style="color: #268bd2;">&#10230;</span> mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g) ps))
                                                  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">This explicit path is in H</span>
         <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" Definition of &#8220;lift &#10814; mor&#8221; on inductive case for paths "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
            mor <span style="color: #b58900; font-style: italic;">F</span> (edge k (edge g e) <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> mor (lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k) (mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g) ps))
         <span style="color: #268bd2;">&#8801;</span>&#10216; functor <span style="color: #b58900; font-style: italic;">F</span> preserves<span style="color: #268bd2;">-</span>composition &#10217;
                mor <span style="color: #b58900; font-style: italic;">F</span> (edge k (edge g e))
           <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">.&#10814;</span>  mor <span style="color: #b58900; font-style: italic;">F</span> (mor (lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k) (mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g) ps))
         <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" Definition of function composition, for top part "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
               (edge g <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> edge k <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span>) e  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8776; mor F &#8728; edge k &#8728; edge g</span>
           <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">.&#10814;</span> (mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g) <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> mor (lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k) <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span>) ps
         <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" &#8220;&#119984;&#8321; &#10814; edge = mor&#8221; and &#8220;edge&#8221; and &#8220;mor&#8221; are functorial by definition "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
                edge (g <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> k <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>) e
           <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">.&#10814;</span>  mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">F</span>) ps
         <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #96A7A9; font-style: italic;">{- </span><span style="color: #96A7A9; font-style: italic;">Inductive Hypothesis: -}</span> <span style="color: #268bd2;">&#8801;-</span>cong&#8322; <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">.</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">&#8801;-</span>refl (proof {p <span style="color: #268bd2;">=</span> ps}) &#10217;
                edge (g <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> k <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>) e
           <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">.&#10814;</span>  mor (lift {<span style="color: #b58900; font-style: italic;">G</span>} {<span style="color: #b58900; font-style: italic;">&#119967;</span>} (g <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> k <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)) ps
         <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" Definition of &#8220;lift &#10814; mor&#8221; on inductive case for paths "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
            mor (lift {<span style="color: #b58900; font-style: italic;">G</span>} {<span style="color: #b58900; font-style: italic;">&#119967;</span>} (g <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> k <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)) (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps)
         <span style="color: #268bd2;">&#8718;</span>
</pre>
</div>

<p>
Formally, we now have an adjunction:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">&#119979;</span><span style="color: #268bd2;">&#8867;</span><span style="color: #b58900; font-style: italic;">&#119984;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119979;</span> <span style="color: #268bd2;">&#8867;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>
<span style="color: #b58900; font-style: italic;">&#119979;</span><span style="color: #268bd2;">&#8867;</span><span style="color: #b58900; font-style: italic;">&#119984;</span> <span style="color: #268bd2;">=</span> record{
    &#8970;<span style="color: #859900; font-weight: bold;">_</span>&#8971; <span style="color: #268bd2;">=</span> lift<span style="color: #268bd2;">&#728;</span>
  ; &#8968;<span style="color: #859900; font-weight: bold;">_</span>&#8969; <span style="color: #268bd2;">=</span> lift
  ; lid <span style="color: #268bd2;">=</span> lid
  ; rid <span style="color: #268bd2;">=</span> &#955; {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> c} <span style="color: #268bd2;">&#8594;</span> rid {<span style="color: #b58900; font-style: italic;">G</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} {c}
  ; lfusion <span style="color: #268bd2;">=</span> &#955; {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> f <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">K</span>} <span style="color: #268bd2;">&#8594;</span> naturality<span style="color: #268bd2;">&#728;</span> {<span style="color: #b58900; font-style: italic;">G</span>} {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} {<span style="color: #b58900; font-style: italic;">&#119967;</span>} f <span style="color: #b58900; font-style: italic;">K</span> {<span style="color: #b58900; font-style: italic;">F</span>}
  ; rfusion <span style="color: #268bd2;">=</span> &#955; {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> f k <span style="color: #b58900; font-style: italic;">F</span>} <span style="color: #268bd2;">&#8594;</span> naturality {<span style="color: #b58900; font-style: italic;">G</span>} {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} {<span style="color: #b58900; font-style: italic;">&#119967;</span>} f <span style="color: #b58900; font-style: italic;">F</span> {k} }
  <span style="color: #859900; font-weight: bold;">where</span>
    <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #859900; font-weight: bold;">_</span> {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span>} <span style="color: #859900; font-weight: bold;">where</span> open freedom <span style="color: #b58900; font-style: italic;">G</span> {<span style="color: #b58900; font-style: italic;">&#119966;</span>} public
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbe4fcfe" class="outline-2">
<h2 id="Folds-Over-Paths">Folds Over Paths</h2>
<div class="outline-text-2" id="text-Folds-Over-Paths">
<p>
Observe that for the freedom proof we recalled
that ists determine a form of quantification, â€˜foldingâ€™:
given an operation âŠ•, we may form the operation <code>[xâ‚, â€¦, xâ‚–] â†¦ xâ‚ âŠ• â‹¯ âŠ• xâ‚–</code>.
Then used that to define our operation <code>lift</code>, whose core was essentially,
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> folding (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>) <span style="color: #859900; font-weight: bold;">where</span>
  open <span style="color: #b58900; font-style: italic;">TypedPaths</span> <span style="color: #b58900; font-style: italic;">G</span>
  open <span style="color: #b58900; font-style: italic;">Graph</span> <span style="color: #b58900; font-style: italic;">G</span>
                                              <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Given:</span>
  fold <span style="color: #b58900; font-style: italic;">:</span> {<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>} (v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>)               <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">realise G's vertices as X elements</span>
         (f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x {y} (e <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>) <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">realise paths as X elements</span>
       <span style="color: #268bd2;">&#8594;</span> (<span style="color: #268bd2;">&#8704;</span> {a b} <span style="color: #268bd2;">&#8594;</span> a <span style="color: #268bd2;">&#8669;</span> b <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>)            <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Then: Any path is an X value</span>
  fold v f (b <span style="color: #268bd2;">!</span>) <span style="color: #268bd2;">=</span> v b
  fold v f (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps) <span style="color: #268bd2;">=</span> f x e (fold v f ps)
</pre>
</div>

<p>
For example, what is the length of a path?
</p>
<div class="org-src-container">
<pre class="src src-haskell">  length <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8669;</span> y <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span>
  length <span style="color: #268bd2;">=</span> fold (&#955; <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">&#8594;</span> 0)          <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">single walks are length 0.</span>
                (&#955; <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> n <span style="color: #268bd2;">&#8594;</span> 1 <span style="color: #268bd2;">+</span> n)  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">edges are one more than the</span>
                                    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">length of the remaining walk</span>
</pre>
</div>
<p>
Letâ€™s verify that this is actually what we intend by the length of a path.
</p>
<div class="org-src-container">
<pre class="src src-haskell">  length<span style="color: #268bd2;">-!</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x} <span style="color: #268bd2;">&#8594;</span> length (x <span style="color: #268bd2;">!</span>) <span style="color: #268bd2;">&#8801;</span> 0
  length<span style="color: #268bd2;">-!</span> <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">True by definition of &#8220;length&#8221;: The first argument to the &#8220;fold&#8221;</span>

  length<span style="color: #268bd2;">-</span>ind <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {x y &#969;} {e <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y} {ps <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#8669;</span> &#969;}
            <span style="color: #268bd2;">&#8594;</span>  length (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps)  <span style="color: #268bd2;">&#8801;</span>  1 <span style="color: #268bd2;">+</span> length ps
  length<span style="color: #268bd2;">-</span>ind <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">True by definition of &#8220;length&#8221;: The second-argument to the &#8220;fold&#8221;</span>
</pre>
</div>

<p>
Generalising on <code>length</code>, suppose we have a â€˜cost functionâ€™ <code>c</code> that assigns a cost of traversing
an edge. Then we can ask what is the total cost of a path:
</p>
<div class="org-src-container">
<pre class="src src-haskell">  path<span style="color: #268bd2;">-</span>cost <span style="color: #b58900; font-style: italic;">:</span> (c <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y}(e <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8704;</span>{x y}(ps <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span>
  path<span style="color: #268bd2;">-</span>cost c <span style="color: #268bd2;">=</span> fold (&#955; <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">&#8594;</span> 0)           <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">No cost on an empty path.</span>
                     (&#955; x e n <span style="color: #268bd2;">&#8594;</span> c e <span style="color: #268bd2;">+</span> n) <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Cost of current edge plus</span>
                                          <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">cost of remainder of path.</span>
</pre>
</div>
<p>
Now, we have <code>length = path-cost (Î» _ â†’ 1)</code>: Length is just assigning a cost of 1 to each edge.
</p>

<p>
Under suitable conditions, list fold distributes over list catenation, can we find an analogue
for paths? Yes. Yes, we can:
</p>
<div class="org-src-container">
<pre class="src src-haskell">  fold<span style="color: #268bd2;">-++</span> <span style="color: #b58900; font-style: italic;">:</span>  <span style="color: #268bd2;">&#8704;</span>{<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>} {v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>} {g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x {y} (e <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>}
          <span style="color: #268bd2;">&#8594;</span> (<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8853;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>)
          <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8704;</span>{x y z <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y} {q <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#8669;</span> z}
          <span style="color: #268bd2;">&#8594;</span> (unitl <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y} <span style="color: #268bd2;">&#8594;</span> y <span style="color: #268bd2;">&#8801;</span> v x <span style="color: #268bd2;">&#8853;</span> y)        <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Image of &#8216;v&#8217; is left unit of &#8853;</span>
          <span style="color: #268bd2;">&#8594;</span> (assoc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {x y z} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8853;</span> (y <span style="color: #268bd2;">&#8853;</span> z) <span style="color: #268bd2;">&#8801;</span> (x <span style="color: #268bd2;">&#8853;</span> y) <span style="color: #268bd2;">&#8853;</span> z )  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8853; is associative</span>
          <span style="color: #268bd2;">&#8594;</span> <span style="color: #859900; font-weight: bold;">let</span> f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x {y} (e <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>
                f <span style="color: #268bd2;">=</span> &#955; x e ps <span style="color: #268bd2;">&#8594;</span> g x e <span style="color: #268bd2;">&#8853;</span> ps
             <span style="color: #859900; font-weight: bold;">in</span>
               fold v f (p <span style="color: #268bd2;">++</span> q) <span style="color: #268bd2;">&#8801;</span> fold v f p <span style="color: #268bd2;">&#8853;</span> fold v f q
  fold<span style="color: #268bd2;">-++</span> {g <span style="color: #268bd2;">=</span> g} <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8853;</span><span style="color: #859900; font-weight: bold;">_</span> {x <span style="color: #268bd2;">=</span> x} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">!</span>} unitl assoc <span style="color: #268bd2;">=</span>  unitl
  fold<span style="color: #268bd2;">-++</span> {g <span style="color: #268bd2;">=</span> g} <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8853;</span><span style="color: #859900; font-weight: bold;">_</span> {x <span style="color: #268bd2;">=</span> x} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} unitl assoc <span style="color: #268bd2;">=</span>
    <span style="color: #268bd2;">&#8801;-</span>cong (&#955; exp <span style="color: #268bd2;">&#8594;</span> g x e <span style="color: #268bd2;">&#8853;</span> exp) (fold<span style="color: #268bd2;">-++</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8853;</span><span style="color: #859900; font-weight: bold;">_</span> {p <span style="color: #268bd2;">=</span> ps} unitl assoc) &#10216;<span style="color: #268bd2;">&#8801;&#8801;</span>&#10217; assoc
</pre>
</div>

<p>
Compare this with the proof-obligation of <code>lift</code>.
</p>
</div>

<div id="outline-container-orgd7e6d82" class="outline-3">
<h3 id="Lists-are-special-kinds-of-paths">Lists are special kinds of paths</h3>
<div class="outline-text-3" id="text-Lists-are-special-kinds-of-paths">
<p>
We called our path catenation <code>_++_</code>, why the same symbol as that for
list catenation?
</p>

<p>
How do we interpret a list over \(A\) as a graph?
Well the vertices can be any element of \(A\)
and an edge \(x âŸ¶ y\) merely indicates that
â€˜â€˜the item after \(x\) in the list is the element \(y\)â€™â€™,
so we want it to be always true; or always inhabited
without distinction of the inhabitant:
So we might as well use a unit type.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> lists (<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>) <span style="color: #859900; font-weight: bold;">where</span>

  open <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Unit</span>

  listGraph <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>
  listGraph <span style="color: #268bd2;">=</span> record { <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">A</span> ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> &#955; a a&#8217; <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8868;</span> }
</pre>
</div>
<p>
I havenâ€™t a clue if this works, you read my reasoning above.
</p>

<p>
The only thing we can do is test our hypothesis by looking at the
typed paths over this graph. In particular, we attempt to show every
non-empty list of \(A\)â€™s corresponds to a path. Since a typed path needs
a priori the start and end vertes, let us construe
<code>List A  â‰…  Î£ n âˆ¶ â„• â€¢ Fin n â†’ A</code>
&#x2013;later note that <code>Path G  â‰…  Î£ n âˆ¶ â„• â€¢ [n] ğ’¢âŸ¶ G</code>.
</p>
<div class="org-src-container">
<pre class="src src-haskell">  open <span style="color: #b58900; font-style: italic;">TypedPaths</span> listGraph
  open folding listGraph

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Every non-empty list [x&#8320;, &#8230;, x&#8342;] of A&#8217;s corresonds to a path x&#8320; &#8669; x&#8342;.</span>
  toPath <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{n} (list <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Fin</span> (suc n) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">A</span>) <span style="color: #268bd2;">&#8594;</span>  list fzero <span style="color: #268bd2;">&#8669;</span> list (from&#8469; n)
  toPath {zero} list <span style="color: #268bd2;">=</span> list fzero <span style="color: #268bd2;">!</span>
  toPath {suc n} list <span style="color: #268bd2;">=</span> list fzero <span style="color: #268bd2;">&#10230;</span>[ tt ]<span style="color: #268bd2;">&#10230;</span> toPath {n} (&#955; i <span style="color: #268bd2;">&#8594;</span> list(fsuc i))
    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Note that in the inductive case, &#8220;list : Fin (suc (suc n)) &#8594; A&#8221;</span>
    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">whereas &#8220;suc &#10814; list : Fin (suc n) &#8594; A&#8221;.</span>
    <span style="color: #96A7A9; font-style: italic;">--</span>
    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">For example, if &#8220;list &#8776; [x , y , z]&#8221; yields</span>
    <span style="color: #96A7A9; font-style: italic;">--          </span><span style="color: #96A7A9; font-style: italic;">&#8220;fsuc &#10814; list &#8776; [y , z ]&#8221; and</span>
    <span style="color: #96A7A9; font-style: italic;">--   </span><span style="color: #96A7A9; font-style: italic;">&#8220;fsuc &#10814; fsuc &#10814; list &#8776; [z]&#8221;.</span>
</pre>
</div>
<p>
Hm! Look at that, first guess and it worked! Sweet.
</p>

<p>
Now letâ€™s realize the list fold as an instance of path fold,
</p>
<div class="org-src-container">
<pre class="src src-haskell">  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">List type former</span>
  <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #268bd2;">=</span> &#955; (<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#931;</span> n <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #268bd2;">&#8226;</span> (<span style="color: #b58900; font-style: italic;">Fin</span> n <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>)

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Usual list folding, but it's in terms of path folding.</span>
  foldr <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{<span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>} (f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span>) (e <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">B</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span>
  foldr f e (zero , l) <span style="color: #268bd2;">=</span> e
  foldr f e (suc n , l) <span style="color: #268bd2;">=</span> fold (&#955; a <span style="color: #268bd2;">&#8594;</span> f a e) (&#955; a <span style="color: #859900; font-weight: bold;">_</span> rem <span style="color: #268bd2;">&#8594;</span> f a rem) (toPath l)

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">example</span>
  listLength <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">result should clearly be &#8220;proj&#8321;&#8221; of the list, anyhow:</span>
  listLength <span style="color: #268bd2;">=</span> foldr
    (&#955; a rem <span style="color: #268bd2;">&#8594;</span> 1 <span style="color: #268bd2;">+</span> rem) <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Non-empty list has length 1 more than the remainder.</span>
    0                    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Empty list has length 0.</span>
</pre>
</div>

<p>
Letâ€™s prepare for a more useful example
</p>
<div class="org-src-container">
<pre class="src src-haskell">  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Empty list</span>
  <span style="color: #b58900; font-style: italic;">[]</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">X</span>
  <span style="color: #b58900; font-style: italic;">[]</span> <span style="color: #268bd2;">=</span> 0 , &#955; <span style="color: #b58900; font-style: italic;">()</span>

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Cons for lists</span>
  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8759;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">X</span>
  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8759;</span><span style="color: #859900; font-weight: bold;">_</span> {<span style="color: #b58900; font-style: italic;">X</span>} x (n , l) <span style="color: #268bd2;">=</span> 1 <span style="color: #268bd2;">+</span> n , cons x l
    <span style="color: #859900; font-weight: bold;">where</span>
      <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8220;cons a l  &#8776;  &#955; i : Fin (1 + n) &#8594; if i &#8776; 0 then a else l i&#8221;</span>
      cons <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{n} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> (<span style="color: #b58900; font-style: italic;">Fin</span> n <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>) <span style="color: #268bd2;">&#8594;</span> (<span style="color: #b58900; font-style: italic;">Fin</span> (suc n) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>)
      cons x l fzero <span style="color: #268bd2;">=</span> x
      cons x l (fsuc i) <span style="color: #268bd2;">=</span> l i

  map <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">B</span>} (f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">B</span>
  map f <span style="color: #268bd2;">=</span>  foldr (&#955; a rem <span style="color: #268bd2;">&#8594;</span> f a <span style="color: #268bd2;">&#8759;</span> rem) <span style="color: #b58900; font-style: italic;">[]</span>  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">looks like the usual map don&#8217;t it ;)</span>

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">list concatenation</span>
  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">++</span>&#8467;_ <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">A</span>
  l <span style="color: #268bd2;">++</span>&#8467; r <span style="color: #268bd2;">=</span> foldr <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8759;</span><span style="color: #859900; font-weight: bold;">_</span> r l <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">fold over &#8216;l&#8217; by consing its elements infront of &#8216;r&#8217;</span>

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Exercise: Write path catenation as a path-fold.</span>
</pre>
</div>

<p>
These few adventures would suggest that much of list theory can be
brought over to the world of paths. It looks promising, let me know
dear reader if you make progress on related explorations!
</p>
</div>
</div>
</div>
<div id="outline-container-orgd76300c" class="outline-2">
<h2 id="That-was-fun-Bye">That was fun; Bye!</h2>
<div class="outline-text-2" id="text-That-was-fun-Bye">
<p>
This note took longer to write than I had initally assumed; perhaps I should have taken into
account
</p>
<dl class="org-dl">
<dt>Hofstadterâ€™s Law</dt><dd><p>
It always takes longer than you expect, even when you take into account Hofstadterâ€™s Law.
</p>

<p>
â”€<a href="https://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach">GÃ¶del, Escher, Bach: An Eternal Golden Braid</a>
</p></dd>
</dl>

<p>
Lessons learned:
</p>

<ul class="org-ul">
<li>In Agda, Use implicits when possible in-favour of instance variables
since the former can be inferred from the local context,
whereas the latter must be resolved using the entire global context
thereby incurring possibly more unification problems to solve
thereby costing more time.</li>

<li>If you really want to learn something, teach it to someone:
A proof assistant wont let you get away with skipping over anything!</li>

<li>Coming up with the right data representation for the tasks being tackled
is a matter of discovery!</li>
</ul>

<p>
The astute reader may have noticed that the tone of writing sometimes
changes drastically. This is because some of this article was written
by me in March 2016 and I wished to preserve interesting writing style
I then had &#x2013;if anything to contrast with my now somewhat semi-formal style.
</p>

<p>
This article was motivated while I was reading <a href="https://www.amazon.ca/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X">Conceptual Mathematics</a>
for fun. One of the problems was to show that paths over a graph form
a category and do so freely. It took me about 20 minutes on paper and pencil,
but this resulting mechanisation took much more time &#x2013;but it was also
much more fun!
</p>

<p>
I had fun writing this up &amp; I hope you enjoy it too :-)
</p>

<dl class="org-dl">
<dt>Highly Recommended Read</dt><dd>The diligent reader may be interested to know that Maarten Fokkinga has written a very
accessible and <a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">gentle introduction to category theory using the calculational approach</a>.</dd>
</dl>

<small>
<div class="org-center">
<p>
( This article is not yet â€˜doneâ€™, but good enough for now. )
</p>
</div>
</small>
</div>
</div>
<div class="taglist"><a href="https://alhassy.github.io/tags.html">Tags</a>: <a href="https://alhassy.github.io/tag-category-theory.html">category-theory</a> <a href="https://alhassy.github.io/tag-agda.html">agda</a> <a href="https://alhassy.github.io/tag-types.html">types</a> </div><div id="archive">
<a href="https://alhassy.github.io/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status"><div id="archive">
  <a href="https://alhassy.github.io/archive.html">Other posts</a>
</div>
<center><a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br /><span xmlns:dct="https://purl.org/dc/terms/" href="https://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">Life and Computing Science</span> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://alhassy.github.io/" property="cc:attributionName" rel="cc:attributionURL">Musa Al-hassy</a> is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.</center>

<div id="archive"><a href="archive.html">Other posts</a></div>
              <div id="disqus_thread"></div>
              <script type="text/javascript">
              /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
              var disqus_shortname = 'life-and-computing-science';
              /* * * DON'T EDIT BELOW THIS LINE * * */
              (function() {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
              </script>
              <noscript>Please enable JavaScript to view the
                  <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
              <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div>
</body>
</html>
